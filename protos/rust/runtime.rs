// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `runtime.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:App.Runtime.MessageRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MessageRequest {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.MessageRequest.uuid)
    pub uuid: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.MessageRequest.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.MessageRequest.object)
    pub object: ::protobuf::MessageField<ObjectConfig>,
    // @@protoc_insertion_point(field:App.Runtime.MessageRequest.pallet)
    pub pallet: ::std::vec::Vec<ObjectConfig>,
    // @@protoc_insertion_point(field:App.Runtime.MessageRequest.body)
    pub body: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:App.Runtime.MessageRequest.command)
    pub command: ::protobuf::MessageField<Command>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.MessageRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageRequest {
    fn default() -> &'a MessageRequest {
        <MessageRequest as ::protobuf::Message>::default_instance()
    }
}

impl MessageRequest {
    pub fn new() -> MessageRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uuid",
            |m: &MessageRequest| { &m.uuid },
            |m: &mut MessageRequest| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &MessageRequest| { &m.key },
            |m: &mut MessageRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ObjectConfig>(
            "object",
            |m: &MessageRequest| { &m.object },
            |m: &mut MessageRequest| { &mut m.object },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pallet",
            |m: &MessageRequest| { &m.pallet },
            |m: &mut MessageRequest| { &mut m.pallet },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "body",
            |m: &MessageRequest| { &m.body },
            |m: &mut MessageRequest| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Command>(
            "command",
            |m: &MessageRequest| { &m.command },
            |m: &mut MessageRequest| { &mut m.command },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageRequest>(
            "MessageRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageRequest {
    const NAME: &'static str = "MessageRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uuid = is.read_string()?;
                },
                18 => {
                    self.key = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.object)?;
                },
                34 => {
                    self.pallet.push(is.read_message()?);
                },
                42 => {
                    self.body = is.read_bytes()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.command)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key);
        }
        if let Some(v) = self.object.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.pallet {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.body);
        }
        if let Some(v) = self.command.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        if !self.key.is_empty() {
            os.write_string(2, &self.key)?;
        }
        if let Some(v) = self.object.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.pallet {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if !self.body.is_empty() {
            os.write_bytes(5, &self.body)?;
        }
        if let Some(v) = self.command.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageRequest {
        MessageRequest::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.key.clear();
        self.object.clear();
        self.pallet.clear();
        self.body.clear();
        self.command.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageRequest {
        static instance: MessageRequest = MessageRequest {
            uuid: ::std::string::String::new(),
            key: ::std::string::String::new(),
            object: ::protobuf::MessageField::none(),
            pallet: ::std::vec::Vec::new(),
            body: ::std::vec::Vec::new(),
            command: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.PluginInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PluginInfo {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.PluginInfo.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.PluginInfo.uuid)
    pub uuid: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.PluginInfo.pallet)
    pub pallet: ::std::vec::Vec<ObjectConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.PluginInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PluginInfo {
    fn default() -> &'a PluginInfo {
        <PluginInfo as ::protobuf::Message>::default_instance()
    }
}

impl PluginInfo {
    pub fn new() -> PluginInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &PluginInfo| { &m.name },
            |m: &mut PluginInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uuid",
            |m: &PluginInfo| { &m.uuid },
            |m: &mut PluginInfo| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pallet",
            |m: &PluginInfo| { &m.pallet },
            |m: &mut PluginInfo| { &mut m.pallet },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PluginInfo>(
            "PluginInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PluginInfo {
    const NAME: &'static str = "PluginInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.uuid = is.read_string()?;
                },
                34 => {
                    self.pallet.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.uuid);
        }
        for value in &self.pallet {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.uuid.is_empty() {
            os.write_string(2, &self.uuid)?;
        }
        for v in &self.pallet {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PluginInfo {
        PluginInfo::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.uuid.clear();
        self.pallet.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PluginInfo {
        static instance: PluginInfo = PluginInfo {
            name: ::std::string::String::new(),
            uuid: ::std::string::String::new(),
            pallet: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PluginInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PluginInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PluginInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PluginInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.PluginResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PluginResponse {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.PluginResponse.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.PluginResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PluginResponse {
    fn default() -> &'a PluginResponse {
        <PluginResponse as ::protobuf::Message>::default_instance()
    }
}

impl PluginResponse {
    pub fn new() -> PluginResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &PluginResponse| { &m.message },
            |m: &mut PluginResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PluginResponse>(
            "PluginResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PluginResponse {
    const NAME: &'static str = "PluginResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PluginResponse {
        PluginResponse::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PluginResponse {
        static instance: PluginResponse = PluginResponse {
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PluginResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PluginResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PluginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PluginResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.PluginList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PluginList {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.PluginList.plugins)
    pub plugins: ::std::vec::Vec<PluginInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.PluginList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PluginList {
    fn default() -> &'a PluginList {
        <PluginList as ::protobuf::Message>::default_instance()
    }
}

impl PluginList {
    pub fn new() -> PluginList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "plugins",
            |m: &PluginList| { &m.plugins },
            |m: &mut PluginList| { &mut m.plugins },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PluginList>(
            "PluginList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PluginList {
    const NAME: &'static str = "PluginList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.plugins.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.plugins {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.plugins {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PluginList {
        PluginList::new()
    }

    fn clear(&mut self) {
        self.plugins.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PluginList {
        static instance: PluginList = PluginList {
            plugins: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PluginList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PluginList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PluginList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PluginList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.GetObjectsValuesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetObjectsValuesResponse {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.GetObjectsValuesResponse.values)
    pub values: ::std::collections::HashMap<::std::string::String, GetObjectValuesResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.GetObjectsValuesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetObjectsValuesResponse {
    fn default() -> &'a GetObjectsValuesResponse {
        <GetObjectsValuesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetObjectsValuesResponse {
    pub fn new() -> GetObjectsValuesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "values",
            |m: &GetObjectsValuesResponse| { &m.values },
            |m: &mut GetObjectsValuesResponse| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetObjectsValuesResponse>(
            "GetObjectsValuesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetObjectsValuesResponse {
    const NAME: &'static str = "GetObjectsValuesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.values.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.values {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.values {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetObjectsValuesResponse {
        GetObjectsValuesResponse::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetObjectsValuesResponse {
        static instance: ::protobuf::rt::Lazy<GetObjectsValuesResponse> = ::protobuf::rt::Lazy::new();
        instance.get(GetObjectsValuesResponse::new)
    }
}

impl ::protobuf::MessageFull for GetObjectsValuesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetObjectsValuesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetObjectsValuesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetObjectsValuesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.GetObjectValuesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetObjectValuesResponse {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.GetObjectValuesResponse.values)
    pub values: ::std::vec::Vec<PortValue>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.GetObjectValuesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetObjectValuesResponse {
    fn default() -> &'a GetObjectValuesResponse {
        <GetObjectValuesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetObjectValuesResponse {
    pub fn new() -> GetObjectValuesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &GetObjectValuesResponse| { &m.values },
            |m: &mut GetObjectValuesResponse| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetObjectValuesResponse>(
            "GetObjectValuesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetObjectValuesResponse {
    const NAME: &'static str = "GetObjectValuesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.values {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetObjectValuesResponse {
        GetObjectValuesResponse::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetObjectValuesResponse {
        static instance: GetObjectValuesResponse = GetObjectValuesResponse {
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetObjectValuesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetObjectValuesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetObjectValuesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetObjectValuesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.ObjectsValuesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObjectsValuesRequest {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.ObjectsValuesRequest.asBytes)
    pub asBytes: bool,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.ObjectsValuesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObjectsValuesRequest {
    fn default() -> &'a ObjectsValuesRequest {
        <ObjectsValuesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ObjectsValuesRequest {
    pub fn new() -> ObjectsValuesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "asBytes",
            |m: &ObjectsValuesRequest| { &m.asBytes },
            |m: &mut ObjectsValuesRequest| { &mut m.asBytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObjectsValuesRequest>(
            "ObjectsValuesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObjectsValuesRequest {
    const NAME: &'static str = "ObjectsValuesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.asBytes = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.asBytes != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.asBytes != false {
            os.write_bool(2, self.asBytes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObjectsValuesRequest {
        ObjectsValuesRequest::new()
    }

    fn clear(&mut self) {
        self.asBytes = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObjectsValuesRequest {
        static instance: ObjectsValuesRequest = ObjectsValuesRequest {
            asBytes: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObjectsValuesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObjectsValuesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObjectsValuesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectsValuesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.ObjectsValueRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObjectsValueRequest {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.ObjectsValueRequest.uuid)
    pub uuid: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectsValueRequest.asBytes)
    pub asBytes: bool,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.ObjectsValueRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObjectsValueRequest {
    fn default() -> &'a ObjectsValueRequest {
        <ObjectsValueRequest as ::protobuf::Message>::default_instance()
    }
}

impl ObjectsValueRequest {
    pub fn new() -> ObjectsValueRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uuid",
            |m: &ObjectsValueRequest| { &m.uuid },
            |m: &mut ObjectsValueRequest| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "asBytes",
            |m: &ObjectsValueRequest| { &m.asBytes },
            |m: &mut ObjectsValueRequest| { &mut m.asBytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObjectsValueRequest>(
            "ObjectsValueRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObjectsValueRequest {
    const NAME: &'static str = "ObjectsValueRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uuid = is.read_string()?;
                },
                16 => {
                    self.asBytes = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        if self.asBytes != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        if self.asBytes != false {
            os.write_bool(2, self.asBytes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObjectsValueRequest {
        ObjectsValueRequest::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.asBytes = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObjectsValueRequest {
        static instance: ObjectsValueRequest = ObjectsValueRequest {
            uuid: ::std::string::String::new(),
            asBytes: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObjectsValueRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObjectsValueRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObjectsValueRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectsValueRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.PortRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PortRequest {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.PortRequest.objectUUID)
    pub objectUUID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.PortRequest.portID)
    pub portID: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.PortRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PortRequest {
    fn default() -> &'a PortRequest {
        <PortRequest as ::protobuf::Message>::default_instance()
    }
}

impl PortRequest {
    pub fn new() -> PortRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "objectUUID",
            |m: &PortRequest| { &m.objectUUID },
            |m: &mut PortRequest| { &mut m.objectUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "portID",
            |m: &PortRequest| { &m.portID },
            |m: &mut PortRequest| { &mut m.portID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PortRequest>(
            "PortRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PortRequest {
    const NAME: &'static str = "PortRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.objectUUID = is.read_string()?;
                },
                18 => {
                    self.portID = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.objectUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.objectUUID);
        }
        if !self.portID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.portID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.objectUUID.is_empty() {
            os.write_string(1, &self.objectUUID)?;
        }
        if !self.portID.is_empty() {
            os.write_string(2, &self.portID)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PortRequest {
        PortRequest::new()
    }

    fn clear(&mut self) {
        self.objectUUID.clear();
        self.portID.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PortRequest {
        static instance: PortRequest = PortRequest {
            objectUUID: ::std::string::String::new(),
            portID: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PortRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PortRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PortRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.PortValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PortValue {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.PortValue.portID)
    pub portID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.PortValue.dataType)
    pub dataType: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.PortValue.isNil)
    pub isNil: bool,
    // @@protoc_insertion_point(field:App.Runtime.PortValue.transformationApplied)
    pub transformationApplied: bool,
    // @@protoc_insertion_point(field:App.Runtime.PortValue.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:App.Runtime.PortValue.number)
    pub number: f64,
    // @@protoc_insertion_point(field:App.Runtime.PortValue.transformation)
    pub transformation: ::protobuf::MessageField<ValueTransformation>,
    // @@protoc_insertion_point(field:App.Runtime.PortValue.portIDs)
    pub portIDs: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.PortValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PortValue {
    fn default() -> &'a PortValue {
        <PortValue as ::protobuf::Message>::default_instance()
    }
}

impl PortValue {
    pub fn new() -> PortValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "portID",
            |m: &PortValue| { &m.portID },
            |m: &mut PortValue| { &mut m.portID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataType",
            |m: &PortValue| { &m.dataType },
            |m: &mut PortValue| { &mut m.dataType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isNil",
            |m: &PortValue| { &m.isNil },
            |m: &mut PortValue| { &mut m.isNil },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transformationApplied",
            |m: &PortValue| { &m.transformationApplied },
            |m: &mut PortValue| { &mut m.transformationApplied },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &PortValue| { &m.data },
            |m: &mut PortValue| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "number",
            |m: &PortValue| { &m.number },
            |m: &mut PortValue| { &mut m.number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ValueTransformation>(
            "transformation",
            |m: &PortValue| { &m.transformation },
            |m: &mut PortValue| { &mut m.transformation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "portIDs",
            |m: &PortValue| { &m.portIDs },
            |m: &mut PortValue| { &mut m.portIDs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PortValue>(
            "PortValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PortValue {
    const NAME: &'static str = "PortValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.portID = is.read_string()?;
                },
                18 => {
                    self.dataType = is.read_string()?;
                },
                24 => {
                    self.isNil = is.read_bool()?;
                },
                32 => {
                    self.transformationApplied = is.read_bool()?;
                },
                42 => {
                    self.data = is.read_bytes()?;
                },
                49 => {
                    self.number = is.read_double()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transformation)?;
                },
                66 => {
                    self.portIDs.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.portID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.portID);
        }
        if !self.dataType.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataType);
        }
        if self.isNil != false {
            my_size += 1 + 1;
        }
        if self.transformationApplied != false {
            my_size += 1 + 1;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.data);
        }
        if self.number != 0. {
            my_size += 1 + 8;
        }
        if let Some(v) = self.transformation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.portIDs {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.portID.is_empty() {
            os.write_string(1, &self.portID)?;
        }
        if !self.dataType.is_empty() {
            os.write_string(2, &self.dataType)?;
        }
        if self.isNil != false {
            os.write_bool(3, self.isNil)?;
        }
        if self.transformationApplied != false {
            os.write_bool(4, self.transformationApplied)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(5, &self.data)?;
        }
        if self.number != 0. {
            os.write_double(6, self.number)?;
        }
        if let Some(v) = self.transformation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.portIDs {
            os.write_string(8, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PortValue {
        PortValue::new()
    }

    fn clear(&mut self) {
        self.portID.clear();
        self.dataType.clear();
        self.isNil = false;
        self.transformationApplied = false;
        self.data.clear();
        self.number = 0.;
        self.transformation.clear();
        self.portIDs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PortValue {
        static instance: PortValue = PortValue {
            portID: ::std::string::String::new(),
            dataType: ::std::string::String::new(),
            isNil: false,
            transformationApplied: false,
            data: ::std::vec::Vec::new(),
            number: 0.,
            transformation: ::protobuf::MessageField::none(),
            portIDs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PortValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PortValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PortValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.ValueTransformation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValueTransformation {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.ValueTransformation.unit)
    pub unit: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ValueTransformation.rawData)
    pub rawData: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.ValueTransformation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValueTransformation {
    fn default() -> &'a ValueTransformation {
        <ValueTransformation as ::protobuf::Message>::default_instance()
    }
}

impl ValueTransformation {
    pub fn new() -> ValueTransformation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unit",
            |m: &ValueTransformation| { &m.unit },
            |m: &mut ValueTransformation| { &mut m.unit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rawData",
            |m: &ValueTransformation| { &m.rawData },
            |m: &mut ValueTransformation| { &mut m.rawData },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValueTransformation>(
            "ValueTransformation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValueTransformation {
    const NAME: &'static str = "ValueTransformation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.unit = is.read_string()?;
                },
                18 => {
                    self.rawData = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.unit.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.unit);
        }
        if !self.rawData.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.rawData);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.unit.is_empty() {
            os.write_string(1, &self.unit)?;
        }
        if !self.rawData.is_empty() {
            os.write_bytes(2, &self.rawData)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValueTransformation {
        ValueTransformation::new()
    }

    fn clear(&mut self) {
        self.unit.clear();
        self.rawData.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValueTransformation {
        static instance: ValueTransformation = ValueTransformation {
            unit: ::std::string::String::new(),
            rawData: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValueTransformation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValueTransformation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValueTransformation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValueTransformation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.ObjectsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObjectsRequest {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.ObjectsRequest.withData)
    pub withData: bool,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.ObjectsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObjectsRequest {
    fn default() -> &'a ObjectsRequest {
        <ObjectsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ObjectsRequest {
    pub fn new() -> ObjectsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "withData",
            |m: &ObjectsRequest| { &m.withData },
            |m: &mut ObjectsRequest| { &mut m.withData },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObjectsRequest>(
            "ObjectsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObjectsRequest {
    const NAME: &'static str = "ObjectsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.withData = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.withData != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.withData != false {
            os.write_bool(1, self.withData)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObjectsRequest {
        ObjectsRequest::new()
    }

    fn clear(&mut self) {
        self.withData = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObjectsRequest {
        static instance: ObjectsRequest = ObjectsRequest {
            withData: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObjectsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObjectsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObjectsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.PalletRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PalletRequest {
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.PalletRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PalletRequest {
    fn default() -> &'a PalletRequest {
        <PalletRequest as ::protobuf::Message>::default_instance()
    }
}

impl PalletRequest {
    pub fn new() -> PalletRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PalletRequest>(
            "PalletRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PalletRequest {
    const NAME: &'static str = "PalletRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PalletRequest {
        PalletRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PalletRequest {
        static instance: PalletRequest = PalletRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PalletRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PalletRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PalletRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PalletRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.PalletTree)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PalletTree {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.PalletTree.plugins)
    pub plugins: ::std::collections::HashMap<::std::string::String, Plugin>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.PalletTree.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PalletTree {
    fn default() -> &'a PalletTree {
        <PalletTree as ::protobuf::Message>::default_instance()
    }
}

impl PalletTree {
    pub fn new() -> PalletTree {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "plugins",
            |m: &PalletTree| { &m.plugins },
            |m: &mut PalletTree| { &mut m.plugins },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PalletTree>(
            "PalletTree",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PalletTree {
    const NAME: &'static str = "PalletTree";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.plugins.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.plugins {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.plugins {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PalletTree {
        PalletTree::new()
    }

    fn clear(&mut self) {
        self.plugins.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PalletTree {
        static instance: ::protobuf::rt::Lazy<PalletTree> = ::protobuf::rt::Lazy::new();
        instance.get(PalletTree::new)
    }
}

impl ::protobuf::MessageFull for PalletTree {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PalletTree").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PalletTree {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PalletTree {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.Plugin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Plugin {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.Plugin.drivers)
    pub drivers: ::std::collections::HashMap<::std::string::String, NestedObjectConfigMap>,
    // @@protoc_insertion_point(field:App.Runtime.Plugin.logic)
    pub logic: ::std::collections::HashMap<::std::string::String, NestedObjectConfigMap>,
    // @@protoc_insertion_point(field:App.Runtime.Plugin.services)
    pub services: ::std::collections::HashMap<::std::string::String, NestedObjectConfigMap>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.Plugin.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Plugin {
    fn default() -> &'a Plugin {
        <Plugin as ::protobuf::Message>::default_instance()
    }
}

impl Plugin {
    pub fn new() -> Plugin {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "drivers",
            |m: &Plugin| { &m.drivers },
            |m: &mut Plugin| { &mut m.drivers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "logic",
            |m: &Plugin| { &m.logic },
            |m: &mut Plugin| { &mut m.logic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "services",
            |m: &Plugin| { &m.services },
            |m: &mut Plugin| { &mut m.services },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Plugin>(
            "Plugin",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Plugin {
    const NAME: &'static str = "Plugin";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.drivers.insert(key, value);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.logic.insert(key, value);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.services.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.drivers {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.logic {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.services {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.drivers {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.logic {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.services {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Plugin {
        Plugin::new()
    }

    fn clear(&mut self) {
        self.drivers.clear();
        self.logic.clear();
        self.services.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Plugin {
        static instance: ::protobuf::rt::Lazy<Plugin> = ::protobuf::rt::Lazy::new();
        instance.get(Plugin::new)
    }
}

impl ::protobuf::MessageFull for Plugin {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Plugin").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Plugin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Plugin {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.NestedObjectConfigMap)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NestedObjectConfigMap {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.NestedObjectConfigMap.entries)
    pub entries: ::std::collections::HashMap<::std::string::String, ObjectConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.NestedObjectConfigMap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NestedObjectConfigMap {
    fn default() -> &'a NestedObjectConfigMap {
        <NestedObjectConfigMap as ::protobuf::Message>::default_instance()
    }
}

impl NestedObjectConfigMap {
    pub fn new() -> NestedObjectConfigMap {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "entries",
            |m: &NestedObjectConfigMap| { &m.entries },
            |m: &mut NestedObjectConfigMap| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NestedObjectConfigMap>(
            "NestedObjectConfigMap",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NestedObjectConfigMap {
    const NAME: &'static str = "NestedObjectConfigMap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.entries.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.entries {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.entries {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NestedObjectConfigMap {
        NestedObjectConfigMap::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NestedObjectConfigMap {
        static instance: ::protobuf::rt::Lazy<NestedObjectConfigMap> = ::protobuf::rt::Lazy::new();
        instance.get(NestedObjectConfigMap::new)
    }
}

impl ::protobuf::MessageFull for NestedObjectConfigMap {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NestedObjectConfigMap").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NestedObjectConfigMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NestedObjectConfigMap {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.Command)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Command {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.Command.targetGlobalID)
    pub targetGlobalID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Command.senderGlobalID)
    pub senderGlobalID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Command.targetObjectUUID)
    pub targetObjectUUID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Command.senderObjectUUID)
    pub senderObjectUUID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Command.transactionUUID)
    pub transactionUUID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Command.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Command.query)
    pub query: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Command.args)
    pub args: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:App.Runtime.Command.data)
    pub data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:App.Runtime.Command.body)
    pub body: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:App.Runtime.Command.object)
    pub object: ::protobuf::MessageField<ObjectConfig>,
    // @@protoc_insertion_point(field:App.Runtime.Command.portValues)
    pub portValues: ::std::vec::Vec<PortValue>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.Command.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Command {
    fn default() -> &'a Command {
        <Command as ::protobuf::Message>::default_instance()
    }
}

impl Command {
    pub fn new() -> Command {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "targetGlobalID",
            |m: &Command| { &m.targetGlobalID },
            |m: &mut Command| { &mut m.targetGlobalID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "senderGlobalID",
            |m: &Command| { &m.senderGlobalID },
            |m: &mut Command| { &mut m.senderGlobalID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "targetObjectUUID",
            |m: &Command| { &m.targetObjectUUID },
            |m: &mut Command| { &mut m.targetObjectUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "senderObjectUUID",
            |m: &Command| { &m.senderObjectUUID },
            |m: &mut Command| { &mut m.senderObjectUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transactionUUID",
            |m: &Command| { &m.transactionUUID },
            |m: &mut Command| { &mut m.transactionUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &Command| { &m.key },
            |m: &mut Command| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query",
            |m: &Command| { &m.query },
            |m: &mut Command| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &Command| { &m.args },
            |m: &mut Command| { &mut m.args },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "data",
            |m: &Command| { &m.data },
            |m: &mut Command| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "body",
            |m: &Command| { &m.body },
            |m: &mut Command| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ObjectConfig>(
            "object",
            |m: &Command| { &m.object },
            |m: &mut Command| { &mut m.object },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "portValues",
            |m: &Command| { &m.portValues },
            |m: &mut Command| { &mut m.portValues },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Command>(
            "Command",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Command {
    const NAME: &'static str = "Command";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.targetGlobalID = is.read_string()?;
                },
                18 => {
                    self.senderGlobalID = is.read_string()?;
                },
                26 => {
                    self.targetObjectUUID = is.read_string()?;
                },
                34 => {
                    self.senderObjectUUID = is.read_string()?;
                },
                42 => {
                    self.transactionUUID = is.read_string()?;
                },
                50 => {
                    self.key = is.read_string()?;
                },
                58 => {
                    self.query = is.read_string()?;
                },
                66 => {
                    self.args.push(is.read_string()?);
                },
                74 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.data.insert(key, value);
                },
                82 => {
                    self.body = is.read_bytes()?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.object)?;
                },
                98 => {
                    self.portValues.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.targetGlobalID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.targetGlobalID);
        }
        if !self.senderGlobalID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.senderGlobalID);
        }
        if !self.targetObjectUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.targetObjectUUID);
        }
        if !self.senderObjectUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.senderObjectUUID);
        }
        if !self.transactionUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.transactionUUID);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.key);
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.query);
        }
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for (k, v) in &self.data {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.body);
        }
        if let Some(v) = self.object.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.portValues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.targetGlobalID.is_empty() {
            os.write_string(1, &self.targetGlobalID)?;
        }
        if !self.senderGlobalID.is_empty() {
            os.write_string(2, &self.senderGlobalID)?;
        }
        if !self.targetObjectUUID.is_empty() {
            os.write_string(3, &self.targetObjectUUID)?;
        }
        if !self.senderObjectUUID.is_empty() {
            os.write_string(4, &self.senderObjectUUID)?;
        }
        if !self.transactionUUID.is_empty() {
            os.write_string(5, &self.transactionUUID)?;
        }
        if !self.key.is_empty() {
            os.write_string(6, &self.key)?;
        }
        if !self.query.is_empty() {
            os.write_string(7, &self.query)?;
        }
        for v in &self.args {
            os.write_string(8, &v)?;
        };
        for (k, v) in &self.data {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(74)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if !self.body.is_empty() {
            os.write_bytes(10, &self.body)?;
        }
        if let Some(v) = self.object.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        for v in &self.portValues {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Command {
        Command::new()
    }

    fn clear(&mut self) {
        self.targetGlobalID.clear();
        self.senderGlobalID.clear();
        self.targetObjectUUID.clear();
        self.senderObjectUUID.clear();
        self.transactionUUID.clear();
        self.key.clear();
        self.query.clear();
        self.args.clear();
        self.data.clear();
        self.body.clear();
        self.object.clear();
        self.portValues.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Command {
        static instance: ::protobuf::rt::Lazy<Command> = ::protobuf::rt::Lazy::new();
        instance.get(Command::new)
    }
}

impl ::protobuf::MessageFull for Command {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Command").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Command {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Command {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.CommandResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandResponse {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.CommandResponse.senderID)
    pub senderID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.CommandResponse.count)
    pub count: i32,
    // @@protoc_insertion_point(field:App.Runtime.CommandResponse.mapStrings)
    pub mapStrings: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:App.Runtime.CommandResponse.number)
    pub number: f64,
    // @@protoc_insertion_point(field:App.Runtime.CommandResponse.boolean)
    pub boolean: bool,
    // @@protoc_insertion_point(field:App.Runtime.CommandResponse.error)
    pub error: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.CommandResponse.returnType)
    pub returnType: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.CommandResponse.any)
    pub any: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:App.Runtime.CommandResponse.response)
    pub response: ::std::vec::Vec<CommandResponse>,
    // @@protoc_insertion_point(field:App.Runtime.CommandResponse.serializeObjects)
    pub serializeObjects: ::std::vec::Vec<ObjectConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.CommandResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CommandResponse {
    fn default() -> &'a CommandResponse {
        <CommandResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommandResponse {
    pub fn new() -> CommandResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "senderID",
            |m: &CommandResponse| { &m.senderID },
            |m: &mut CommandResponse| { &mut m.senderID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &CommandResponse| { &m.count },
            |m: &mut CommandResponse| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "mapStrings",
            |m: &CommandResponse| { &m.mapStrings },
            |m: &mut CommandResponse| { &mut m.mapStrings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "number",
            |m: &CommandResponse| { &m.number },
            |m: &mut CommandResponse| { &mut m.number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "boolean",
            |m: &CommandResponse| { &m.boolean },
            |m: &mut CommandResponse| { &mut m.boolean },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &CommandResponse| { &m.error },
            |m: &mut CommandResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "returnType",
            |m: &CommandResponse| { &m.returnType },
            |m: &mut CommandResponse| { &mut m.returnType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "any",
            |m: &CommandResponse| { &m.any },
            |m: &mut CommandResponse| { &mut m.any },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "response",
            |m: &CommandResponse| { &m.response },
            |m: &mut CommandResponse| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "serializeObjects",
            |m: &CommandResponse| { &m.serializeObjects },
            |m: &mut CommandResponse| { &mut m.serializeObjects },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CommandResponse>(
            "CommandResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CommandResponse {
    const NAME: &'static str = "CommandResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.senderID = is.read_string()?;
                },
                16 => {
                    self.count = is.read_int32()?;
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.mapStrings.insert(key, value);
                },
                33 => {
                    self.number = is.read_double()?;
                },
                40 => {
                    self.boolean = is.read_bool()?;
                },
                50 => {
                    self.error = is.read_string()?;
                },
                58 => {
                    self.returnType = is.read_string()?;
                },
                66 => {
                    self.any = is.read_bytes()?;
                },
                74 => {
                    self.response.push(is.read_message()?);
                },
                82 => {
                    self.serializeObjects.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.senderID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.senderID);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.count);
        }
        for (k, v) in &self.mapStrings {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.number != 0. {
            my_size += 1 + 8;
        }
        if self.boolean != false {
            my_size += 1 + 1;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.error);
        }
        if !self.returnType.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.returnType);
        }
        if !self.any.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.any);
        }
        for value in &self.response {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.serializeObjects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.senderID.is_empty() {
            os.write_string(1, &self.senderID)?;
        }
        if self.count != 0 {
            os.write_int32(2, self.count)?;
        }
        for (k, v) in &self.mapStrings {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if self.number != 0. {
            os.write_double(4, self.number)?;
        }
        if self.boolean != false {
            os.write_bool(5, self.boolean)?;
        }
        if !self.error.is_empty() {
            os.write_string(6, &self.error)?;
        }
        if !self.returnType.is_empty() {
            os.write_string(7, &self.returnType)?;
        }
        if !self.any.is_empty() {
            os.write_bytes(8, &self.any)?;
        }
        for v in &self.response {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.serializeObjects {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CommandResponse {
        CommandResponse::new()
    }

    fn clear(&mut self) {
        self.senderID.clear();
        self.count = 0;
        self.mapStrings.clear();
        self.number = 0.;
        self.boolean = false;
        self.error.clear();
        self.returnType.clear();
        self.any.clear();
        self.response.clear();
        self.serializeObjects.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CommandResponse {
        static instance: ::protobuf::rt::Lazy<CommandResponse> = ::protobuf::rt::Lazy::new();
        instance.get(CommandResponse::new)
    }
}

impl ::protobuf::MessageFull for CommandResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CommandResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CommandResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  New message for the Ping request
// @@protoc_insertion_point(message:App.Runtime.PingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PingRequest {
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.PingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PingRequest {
    fn default() -> &'a PingRequest {
        <PingRequest as ::protobuf::Message>::default_instance()
    }
}

impl PingRequest {
    pub fn new() -> PingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingRequest>(
            "PingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingRequest {
    const NAME: &'static str = "PingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingRequest {
        PingRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingRequest {
        static instance: PingRequest = PingRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  New message for the Ping response
// @@protoc_insertion_point(message:App.Runtime.PingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PingResponse {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.PingResponse.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.PingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PingResponse {
    fn default() -> &'a PingResponse {
        <PingResponse as ::protobuf::Message>::default_instance()
    }
}

impl PingResponse {
    pub fn new() -> PingResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &PingResponse| { &m.message },
            |m: &mut PingResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingResponse>(
            "PingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingResponse {
    const NAME: &'static str = "PingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingResponse {
        PingResponse::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingResponse {
        static instance: PingResponse = PingResponse {
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.ObjectDeploy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObjectDeploy {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.ObjectDeploy.deleted)
    pub deleted: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:App.Runtime.ObjectDeploy.new)
    pub new: ::std::vec::Vec<ObjectConfig>,
    // @@protoc_insertion_point(field:App.Runtime.ObjectDeploy.updated)
    pub updated: ::std::vec::Vec<ObjectConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.ObjectDeploy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObjectDeploy {
    fn default() -> &'a ObjectDeploy {
        <ObjectDeploy as ::protobuf::Message>::default_instance()
    }
}

impl ObjectDeploy {
    pub fn new() -> ObjectDeploy {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deleted",
            |m: &ObjectDeploy| { &m.deleted },
            |m: &mut ObjectDeploy| { &mut m.deleted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "new",
            |m: &ObjectDeploy| { &m.new },
            |m: &mut ObjectDeploy| { &mut m.new },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "updated",
            |m: &ObjectDeploy| { &m.updated },
            |m: &mut ObjectDeploy| { &mut m.updated },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObjectDeploy>(
            "ObjectDeploy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObjectDeploy {
    const NAME: &'static str = "ObjectDeploy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.deleted.push(is.read_string()?);
                },
                18 => {
                    self.new.push(is.read_message()?);
                },
                26 => {
                    self.updated.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.deleted {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.new {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.updated {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.deleted {
            os.write_string(1, &v)?;
        };
        for v in &self.new {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.updated {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObjectDeploy {
        ObjectDeploy::new()
    }

    fn clear(&mut self) {
        self.deleted.clear();
        self.new.clear();
        self.updated.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObjectDeploy {
        static instance: ObjectDeploy = ObjectDeploy {
            deleted: ::std::vec::Vec::new(),
            new: ::std::vec::Vec::new(),
            updated: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObjectDeploy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObjectDeploy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObjectDeploy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectDeploy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.Empty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Empty {
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.Empty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Empty {
    fn default() -> &'a Empty {
        <Empty as ::protobuf::Message>::default_instance()
    }
}

impl Empty {
    pub fn new() -> Empty {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Empty>(
            "Empty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Empty {
    const NAME: &'static str = "Empty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Empty {
        Empty::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Empty {
        static instance: Empty = Empty {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Empty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Empty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Empty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Empty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.ObjectsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObjectsResponse {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.ObjectsResponse.objects)
    pub objects: ::std::vec::Vec<ObjectConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.ObjectsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObjectsResponse {
    fn default() -> &'a ObjectsResponse {
        <ObjectsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ObjectsResponse {
    pub fn new() -> ObjectsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "objects",
            |m: &ObjectsResponse| { &m.objects },
            |m: &mut ObjectsResponse| { &mut m.objects },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObjectsResponse>(
            "ObjectsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObjectsResponse {
    const NAME: &'static str = "ObjectsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.objects.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.objects {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObjectsResponse {
        ObjectsResponse::new()
    }

    fn clear(&mut self) {
        self.objects.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObjectsResponse {
        static instance: ObjectsResponse = ObjectsResponse {
            objects: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObjectsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObjectsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObjectsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.ObjectRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObjectRequest {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.ObjectRequest.uuid)
    pub uuid: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectRequest.withPoints)
    pub withPoints: bool,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.ObjectRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObjectRequest {
    fn default() -> &'a ObjectRequest {
        <ObjectRequest as ::protobuf::Message>::default_instance()
    }
}

impl ObjectRequest {
    pub fn new() -> ObjectRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uuid",
            |m: &ObjectRequest| { &m.uuid },
            |m: &mut ObjectRequest| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "withPoints",
            |m: &ObjectRequest| { &m.withPoints },
            |m: &mut ObjectRequest| { &mut m.withPoints },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObjectRequest>(
            "ObjectRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObjectRequest {
    const NAME: &'static str = "ObjectRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uuid = is.read_string()?;
                },
                16 => {
                    self.withPoints = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        if self.withPoints != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        if self.withPoints != false {
            os.write_bool(2, self.withPoints)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObjectRequest {
        ObjectRequest::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.withPoints = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObjectRequest {
        static instance: ObjectRequest = ObjectRequest {
            uuid: ::std::string::String::new(),
            withPoints: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObjectRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObjectRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObjectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.ObjectConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObjectConfig {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.ObjectConfig.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectConfig.info)
    pub info: ::protobuf::MessageField<Info>,
    // @@protoc_insertion_point(field:App.Runtime.ObjectConfig.inputs)
    pub inputs: ::std::vec::Vec<Port>,
    // @@protoc_insertion_point(field:App.Runtime.ObjectConfig.outputs)
    pub outputs: ::std::vec::Vec<Port>,
    // @@protoc_insertion_point(field:App.Runtime.ObjectConfig.meta)
    pub meta: ::protobuf::MessageField<Meta>,
    // @@protoc_insertion_point(field:App.Runtime.ObjectConfig.stats)
    pub stats: ::protobuf::MessageField<ObjectStats>,
    // @@protoc_insertion_point(field:App.Runtime.ObjectConfig.connections)
    pub connections: ::std::vec::Vec<Connection>,
    // @@protoc_insertion_point(field:App.Runtime.ObjectConfig.settings)
    pub settings: ::protobuf::MessageField<Settings>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.ObjectConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObjectConfig {
    fn default() -> &'a ObjectConfig {
        <ObjectConfig as ::protobuf::Message>::default_instance()
    }
}

impl ObjectConfig {
    pub fn new() -> ObjectConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ObjectConfig| { &m.id },
            |m: &mut ObjectConfig| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Info>(
            "info",
            |m: &ObjectConfig| { &m.info },
            |m: &mut ObjectConfig| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &ObjectConfig| { &m.inputs },
            |m: &mut ObjectConfig| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outputs",
            |m: &ObjectConfig| { &m.outputs },
            |m: &mut ObjectConfig| { &mut m.outputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Meta>(
            "meta",
            |m: &ObjectConfig| { &m.meta },
            |m: &mut ObjectConfig| { &mut m.meta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ObjectStats>(
            "stats",
            |m: &ObjectConfig| { &m.stats },
            |m: &mut ObjectConfig| { &mut m.stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "connections",
            |m: &ObjectConfig| { &m.connections },
            |m: &mut ObjectConfig| { &mut m.connections },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Settings>(
            "settings",
            |m: &ObjectConfig| { &m.settings },
            |m: &mut ObjectConfig| { &mut m.settings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObjectConfig>(
            "ObjectConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObjectConfig {
    const NAME: &'static str = "ObjectConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                26 => {
                    self.inputs.push(is.read_message()?);
                },
                34 => {
                    self.outputs.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meta)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                58 => {
                    self.connections.push(is.read_message()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.connections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.outputs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.meta.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.connections {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObjectConfig {
        ObjectConfig::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.info.clear();
        self.inputs.clear();
        self.outputs.clear();
        self.meta.clear();
        self.stats.clear();
        self.connections.clear();
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObjectConfig {
        static instance: ObjectConfig = ObjectConfig {
            id: ::std::string::String::new(),
            info: ::protobuf::MessageField::none(),
            inputs: ::std::vec::Vec::new(),
            outputs: ::std::vec::Vec::new(),
            meta: ::protobuf::MessageField::none(),
            stats: ::protobuf::MessageField::none(),
            connections: ::std::vec::Vec::new(),
            settings: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObjectConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObjectConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObjectConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.Settings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Settings {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.Settings.value)
    pub value: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.Settings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Settings {
    fn default() -> &'a Settings {
        <Settings as ::protobuf::Message>::default_instance()
    }
}

impl Settings {
    pub fn new() -> Settings {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Settings| { &m.value },
            |m: &mut Settings| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Settings>(
            "Settings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Settings {
    const NAME: &'static str = "Settings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Settings {
        Settings::new()
    }

    fn clear(&mut self) {
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Settings {
        static instance: Settings = Settings {
            value: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Settings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Settings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Settings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Settings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.Info)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Info {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.Info.objectID)
    pub objectID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Info.objectType)
    pub objectType: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Info.category)
    pub category: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Info.pluginName)
    pub pluginName: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Info.workingGroup)
    pub workingGroup: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Info.workingGroupLeader)
    pub workingGroupLeader: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Info.workingGroupParent)
    pub workingGroupParent: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Info.workingGroupObjects)
    pub workingGroupObjects: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:App.Runtime.Info.workingGroupChildObjects)
    pub workingGroupChildObjects: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:App.Runtime.Info.objectTags)
    pub objectTags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:App.Runtime.Info.permissions)
    pub permissions: ::protobuf::MessageField<Permissions>,
    // @@protoc_insertion_point(field:App.Runtime.Info.requirements)
    pub requirements: ::protobuf::MessageField<Requirements>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.Info.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Info {
    fn default() -> &'a Info {
        <Info as ::protobuf::Message>::default_instance()
    }
}

impl Info {
    pub fn new() -> Info {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "objectID",
            |m: &Info| { &m.objectID },
            |m: &mut Info| { &mut m.objectID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "objectType",
            |m: &Info| { &m.objectType },
            |m: &mut Info| { &mut m.objectType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "category",
            |m: &Info| { &m.category },
            |m: &mut Info| { &mut m.category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pluginName",
            |m: &Info| { &m.pluginName },
            |m: &mut Info| { &mut m.pluginName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workingGroup",
            |m: &Info| { &m.workingGroup },
            |m: &mut Info| { &mut m.workingGroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workingGroupLeader",
            |m: &Info| { &m.workingGroupLeader },
            |m: &mut Info| { &mut m.workingGroupLeader },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workingGroupParent",
            |m: &Info| { &m.workingGroupParent },
            |m: &mut Info| { &mut m.workingGroupParent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workingGroupObjects",
            |m: &Info| { &m.workingGroupObjects },
            |m: &mut Info| { &mut m.workingGroupObjects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workingGroupChildObjects",
            |m: &Info| { &m.workingGroupChildObjects },
            |m: &mut Info| { &mut m.workingGroupChildObjects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "objectTags",
            |m: &Info| { &m.objectTags },
            |m: &mut Info| { &mut m.objectTags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Permissions>(
            "permissions",
            |m: &Info| { &m.permissions },
            |m: &mut Info| { &mut m.permissions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Requirements>(
            "requirements",
            |m: &Info| { &m.requirements },
            |m: &mut Info| { &mut m.requirements },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Info>(
            "Info",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Info {
    const NAME: &'static str = "Info";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.objectID = is.read_string()?;
                },
                18 => {
                    self.objectType = is.read_string()?;
                },
                26 => {
                    self.category = is.read_string()?;
                },
                34 => {
                    self.pluginName = is.read_string()?;
                },
                42 => {
                    self.workingGroup = is.read_string()?;
                },
                50 => {
                    self.workingGroupLeader = is.read_string()?;
                },
                58 => {
                    self.workingGroupParent = is.read_string()?;
                },
                66 => {
                    self.workingGroupObjects.push(is.read_string()?);
                },
                74 => {
                    self.workingGroupChildObjects.push(is.read_string()?);
                },
                82 => {
                    self.objectTags.push(is.read_string()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.permissions)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.requirements)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.objectID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.objectID);
        }
        if !self.objectType.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.objectType);
        }
        if !self.category.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.category);
        }
        if !self.pluginName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.pluginName);
        }
        if !self.workingGroup.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.workingGroup);
        }
        if !self.workingGroupLeader.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.workingGroupLeader);
        }
        if !self.workingGroupParent.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.workingGroupParent);
        }
        for value in &self.workingGroupObjects {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.workingGroupChildObjects {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.objectTags {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(v) = self.permissions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.requirements.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.objectID.is_empty() {
            os.write_string(1, &self.objectID)?;
        }
        if !self.objectType.is_empty() {
            os.write_string(2, &self.objectType)?;
        }
        if !self.category.is_empty() {
            os.write_string(3, &self.category)?;
        }
        if !self.pluginName.is_empty() {
            os.write_string(4, &self.pluginName)?;
        }
        if !self.workingGroup.is_empty() {
            os.write_string(5, &self.workingGroup)?;
        }
        if !self.workingGroupLeader.is_empty() {
            os.write_string(6, &self.workingGroupLeader)?;
        }
        if !self.workingGroupParent.is_empty() {
            os.write_string(7, &self.workingGroupParent)?;
        }
        for v in &self.workingGroupObjects {
            os.write_string(8, &v)?;
        };
        for v in &self.workingGroupChildObjects {
            os.write_string(9, &v)?;
        };
        for v in &self.objectTags {
            os.write_string(10, &v)?;
        };
        if let Some(v) = self.permissions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.requirements.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Info {
        Info::new()
    }

    fn clear(&mut self) {
        self.objectID.clear();
        self.objectType.clear();
        self.category.clear();
        self.pluginName.clear();
        self.workingGroup.clear();
        self.workingGroupLeader.clear();
        self.workingGroupParent.clear();
        self.workingGroupObjects.clear();
        self.workingGroupChildObjects.clear();
        self.objectTags.clear();
        self.permissions.clear();
        self.requirements.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Info {
        static instance: Info = Info {
            objectID: ::std::string::String::new(),
            objectType: ::std::string::String::new(),
            category: ::std::string::String::new(),
            pluginName: ::std::string::String::new(),
            workingGroup: ::std::string::String::new(),
            workingGroupLeader: ::std::string::String::new(),
            workingGroupParent: ::std::string::String::new(),
            workingGroupObjects: ::std::vec::Vec::new(),
            workingGroupChildObjects: ::std::vec::Vec::new(),
            objectTags: ::std::vec::Vec::new(),
            permissions: ::protobuf::MessageField::none(),
            requirements: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Info {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Info").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Info {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Info {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.Permissions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Permissions {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.Permissions.allPermissions)
    pub allPermissions: bool,
    // @@protoc_insertion_point(field:App.Runtime.Permissions.canBeCreated)
    pub canBeCreated: bool,
    // @@protoc_insertion_point(field:App.Runtime.Permissions.canBeDeleted)
    pub canBeDeleted: bool,
    // @@protoc_insertion_point(field:App.Runtime.Permissions.canBeUpdated)
    pub canBeUpdated: bool,
    // @@protoc_insertion_point(field:App.Runtime.Permissions.readOnly)
    pub readOnly: bool,
    // @@protoc_insertion_point(field:App.Runtime.Permissions.allowHotFix)
    pub allowHotFix: bool,
    // @@protoc_insertion_point(field:App.Runtime.Permissions.forceDelete)
    pub forceDelete: bool,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.Permissions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Permissions {
    fn default() -> &'a Permissions {
        <Permissions as ::protobuf::Message>::default_instance()
    }
}

impl Permissions {
    pub fn new() -> Permissions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allPermissions",
            |m: &Permissions| { &m.allPermissions },
            |m: &mut Permissions| { &mut m.allPermissions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "canBeCreated",
            |m: &Permissions| { &m.canBeCreated },
            |m: &mut Permissions| { &mut m.canBeCreated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "canBeDeleted",
            |m: &Permissions| { &m.canBeDeleted },
            |m: &mut Permissions| { &mut m.canBeDeleted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "canBeUpdated",
            |m: &Permissions| { &m.canBeUpdated },
            |m: &mut Permissions| { &mut m.canBeUpdated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "readOnly",
            |m: &Permissions| { &m.readOnly },
            |m: &mut Permissions| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowHotFix",
            |m: &Permissions| { &m.allowHotFix },
            |m: &mut Permissions| { &mut m.allowHotFix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "forceDelete",
            |m: &Permissions| { &m.forceDelete },
            |m: &mut Permissions| { &mut m.forceDelete },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Permissions>(
            "Permissions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Permissions {
    const NAME: &'static str = "Permissions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.allPermissions = is.read_bool()?;
                },
                16 => {
                    self.canBeCreated = is.read_bool()?;
                },
                24 => {
                    self.canBeDeleted = is.read_bool()?;
                },
                32 => {
                    self.canBeUpdated = is.read_bool()?;
                },
                40 => {
                    self.readOnly = is.read_bool()?;
                },
                48 => {
                    self.allowHotFix = is.read_bool()?;
                },
                56 => {
                    self.forceDelete = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.allPermissions != false {
            my_size += 1 + 1;
        }
        if self.canBeCreated != false {
            my_size += 1 + 1;
        }
        if self.canBeDeleted != false {
            my_size += 1 + 1;
        }
        if self.canBeUpdated != false {
            my_size += 1 + 1;
        }
        if self.readOnly != false {
            my_size += 1 + 1;
        }
        if self.allowHotFix != false {
            my_size += 1 + 1;
        }
        if self.forceDelete != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.allPermissions != false {
            os.write_bool(1, self.allPermissions)?;
        }
        if self.canBeCreated != false {
            os.write_bool(2, self.canBeCreated)?;
        }
        if self.canBeDeleted != false {
            os.write_bool(3, self.canBeDeleted)?;
        }
        if self.canBeUpdated != false {
            os.write_bool(4, self.canBeUpdated)?;
        }
        if self.readOnly != false {
            os.write_bool(5, self.readOnly)?;
        }
        if self.allowHotFix != false {
            os.write_bool(6, self.allowHotFix)?;
        }
        if self.forceDelete != false {
            os.write_bool(7, self.forceDelete)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Permissions {
        Permissions::new()
    }

    fn clear(&mut self) {
        self.allPermissions = false;
        self.canBeCreated = false;
        self.canBeDeleted = false;
        self.canBeUpdated = false;
        self.readOnly = false;
        self.allowHotFix = false;
        self.forceDelete = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Permissions {
        static instance: Permissions = Permissions {
            allPermissions: false,
            canBeCreated: false,
            canBeDeleted: false,
            canBeUpdated: false,
            readOnly: false,
            allowHotFix: false,
            forceDelete: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Permissions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Permissions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Permissions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Permissions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.Requirements)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Requirements {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.Requirements.callResetOnDeploy)
    pub callResetOnDeploy: bool,
    // @@protoc_insertion_point(field:App.Runtime.Requirements.allowRuntimeAccess)
    pub allowRuntimeAccess: bool,
    // @@protoc_insertion_point(field:App.Runtime.Requirements.maxOne)
    pub maxOne: bool,
    // @@protoc_insertion_point(field:App.Runtime.Requirements.mustLiveInObjectType)
    pub mustLiveInObjectType: bool,
    // @@protoc_insertion_point(field:App.Runtime.Requirements.mustLiveParent)
    pub mustLiveParent: bool,
    // @@protoc_insertion_point(field:App.Runtime.Requirements.requiresLogger)
    pub requiresLogger: bool,
    // @@protoc_insertion_point(field:App.Runtime.Requirements.supportsActions)
    pub supportsActions: bool,
    // @@protoc_insertion_point(field:App.Runtime.Requirements.servicesRequirements)
    pub servicesRequirements: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:App.Runtime.Requirements.loggerOptions)
    pub loggerOptions: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.Requirements.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Requirements {
    fn default() -> &'a Requirements {
        <Requirements as ::protobuf::Message>::default_instance()
    }
}

impl Requirements {
    pub fn new() -> Requirements {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "callResetOnDeploy",
            |m: &Requirements| { &m.callResetOnDeploy },
            |m: &mut Requirements| { &mut m.callResetOnDeploy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allowRuntimeAccess",
            |m: &Requirements| { &m.allowRuntimeAccess },
            |m: &mut Requirements| { &mut m.allowRuntimeAccess },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "maxOne",
            |m: &Requirements| { &m.maxOne },
            |m: &mut Requirements| { &mut m.maxOne },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mustLiveInObjectType",
            |m: &Requirements| { &m.mustLiveInObjectType },
            |m: &mut Requirements| { &mut m.mustLiveInObjectType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mustLiveParent",
            |m: &Requirements| { &m.mustLiveParent },
            |m: &mut Requirements| { &mut m.mustLiveParent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requiresLogger",
            |m: &Requirements| { &m.requiresLogger },
            |m: &mut Requirements| { &mut m.requiresLogger },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supportsActions",
            |m: &Requirements| { &m.supportsActions },
            |m: &mut Requirements| { &mut m.supportsActions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "servicesRequirements",
            |m: &Requirements| { &m.servicesRequirements },
            |m: &mut Requirements| { &mut m.servicesRequirements },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "loggerOptions",
            |m: &Requirements| { &m.loggerOptions },
            |m: &mut Requirements| { &mut m.loggerOptions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Requirements>(
            "Requirements",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Requirements {
    const NAME: &'static str = "Requirements";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.callResetOnDeploy = is.read_bool()?;
                },
                16 => {
                    self.allowRuntimeAccess = is.read_bool()?;
                },
                24 => {
                    self.maxOne = is.read_bool()?;
                },
                32 => {
                    self.mustLiveInObjectType = is.read_bool()?;
                },
                40 => {
                    self.mustLiveParent = is.read_bool()?;
                },
                48 => {
                    self.requiresLogger = is.read_bool()?;
                },
                56 => {
                    self.supportsActions = is.read_bool()?;
                },
                66 => {
                    self.servicesRequirements.push(is.read_string()?);
                },
                74 => {
                    self.loggerOptions.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.callResetOnDeploy != false {
            my_size += 1 + 1;
        }
        if self.allowRuntimeAccess != false {
            my_size += 1 + 1;
        }
        if self.maxOne != false {
            my_size += 1 + 1;
        }
        if self.mustLiveInObjectType != false {
            my_size += 1 + 1;
        }
        if self.mustLiveParent != false {
            my_size += 1 + 1;
        }
        if self.requiresLogger != false {
            my_size += 1 + 1;
        }
        if self.supportsActions != false {
            my_size += 1 + 1;
        }
        for value in &self.servicesRequirements {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.loggerOptions {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.callResetOnDeploy != false {
            os.write_bool(1, self.callResetOnDeploy)?;
        }
        if self.allowRuntimeAccess != false {
            os.write_bool(2, self.allowRuntimeAccess)?;
        }
        if self.maxOne != false {
            os.write_bool(3, self.maxOne)?;
        }
        if self.mustLiveInObjectType != false {
            os.write_bool(4, self.mustLiveInObjectType)?;
        }
        if self.mustLiveParent != false {
            os.write_bool(5, self.mustLiveParent)?;
        }
        if self.requiresLogger != false {
            os.write_bool(6, self.requiresLogger)?;
        }
        if self.supportsActions != false {
            os.write_bool(7, self.supportsActions)?;
        }
        for v in &self.servicesRequirements {
            os.write_string(8, &v)?;
        };
        for v in &self.loggerOptions {
            os.write_string(9, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Requirements {
        Requirements::new()
    }

    fn clear(&mut self) {
        self.callResetOnDeploy = false;
        self.allowRuntimeAccess = false;
        self.maxOne = false;
        self.mustLiveInObjectType = false;
        self.mustLiveParent = false;
        self.requiresLogger = false;
        self.supportsActions = false;
        self.servicesRequirements.clear();
        self.loggerOptions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Requirements {
        static instance: Requirements = Requirements {
            callResetOnDeploy: false,
            allowRuntimeAccess: false,
            maxOne: false,
            mustLiveInObjectType: false,
            mustLiveParent: false,
            requiresLogger: false,
            supportsActions: false,
            servicesRequirements: ::std::vec::Vec::new(),
            loggerOptions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Requirements {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Requirements").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Requirements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Requirements {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.ObjectStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObjectStats {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.ObjectStats.status)
    pub status: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectStats.loaded)
    pub loaded: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectStats.loopCount)
    pub loopCount: u32,
    // @@protoc_insertion_point(field:App.Runtime.ObjectStats.timeSince)
    pub timeSince: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.ObjectStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObjectStats {
    fn default() -> &'a ObjectStats {
        <ObjectStats as ::protobuf::Message>::default_instance()
    }
}

impl ObjectStats {
    pub fn new() -> ObjectStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &ObjectStats| { &m.status },
            |m: &mut ObjectStats| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "loaded",
            |m: &ObjectStats| { &m.loaded },
            |m: &mut ObjectStats| { &mut m.loaded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "loopCount",
            |m: &ObjectStats| { &m.loopCount },
            |m: &mut ObjectStats| { &mut m.loopCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timeSince",
            |m: &ObjectStats| { &m.timeSince },
            |m: &mut ObjectStats| { &mut m.timeSince },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObjectStats>(
            "ObjectStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObjectStats {
    const NAME: &'static str = "ObjectStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.status = is.read_string()?;
                },
                18 => {
                    self.loaded = is.read_string()?;
                },
                24 => {
                    self.loopCount = is.read_uint32()?;
                },
                50 => {
                    self.timeSince = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status);
        }
        if !self.loaded.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.loaded);
        }
        if self.loopCount != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.loopCount);
        }
        if !self.timeSince.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.timeSince);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.status.is_empty() {
            os.write_string(1, &self.status)?;
        }
        if !self.loaded.is_empty() {
            os.write_string(2, &self.loaded)?;
        }
        if self.loopCount != 0 {
            os.write_uint32(3, self.loopCount)?;
        }
        if !self.timeSince.is_empty() {
            os.write_string(6, &self.timeSince)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObjectStats {
        ObjectStats::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.loaded.clear();
        self.loopCount = 0;
        self.timeSince.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObjectStats {
        static instance: ObjectStats = ObjectStats {
            status: ::std::string::String::new(),
            loaded: ::std::string::String::new(),
            loopCount: 0,
            timeSince: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObjectStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObjectStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObjectStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.Port)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Port {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.Port.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Port.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Port.portUUID)
    pub portUUID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Port.direction)
    pub direction: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Port.dataType)
    pub dataType: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Port.defaultPosition)
    pub defaultPosition: i32,
    // @@protoc_insertion_point(field:App.Runtime.Port.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.Port.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Port {
    fn default() -> &'a Port {
        <Port as ::protobuf::Message>::default_instance()
    }
}

impl Port {
    pub fn new() -> Port {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Port| { &m.id },
            |m: &mut Port| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Port| { &m.name },
            |m: &mut Port| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "portUUID",
            |m: &Port| { &m.portUUID },
            |m: &mut Port| { &mut m.portUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &Port| { &m.direction },
            |m: &mut Port| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataType",
            |m: &Port| { &m.dataType },
            |m: &mut Port| { &mut m.dataType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "defaultPosition",
            |m: &Port| { &m.defaultPosition },
            |m: &mut Port| { &mut m.defaultPosition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Port| { &m.value },
            |m: &mut Port| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Port>(
            "Port",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Port {
    const NAME: &'static str = "Port";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.portUUID = is.read_string()?;
                },
                34 => {
                    self.direction = is.read_string()?;
                },
                42 => {
                    self.dataType = is.read_string()?;
                },
                48 => {
                    self.defaultPosition = is.read_int32()?;
                },
                58 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.portUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.portUUID);
        }
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.direction);
        }
        if !self.dataType.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.dataType);
        }
        if self.defaultPosition != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.defaultPosition);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.portUUID.is_empty() {
            os.write_string(3, &self.portUUID)?;
        }
        if !self.direction.is_empty() {
            os.write_string(4, &self.direction)?;
        }
        if !self.dataType.is_empty() {
            os.write_string(5, &self.dataType)?;
        }
        if self.defaultPosition != 0 {
            os.write_int32(6, self.defaultPosition)?;
        }
        if !self.value.is_empty() {
            os.write_string(7, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Port {
        Port::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.portUUID.clear();
        self.direction.clear();
        self.dataType.clear();
        self.defaultPosition = 0;
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Port {
        static instance: Port = Port {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            portUUID: ::std::string::String::new(),
            direction: ::std::string::String::new(),
            dataType: ::std::string::String::new(),
            defaultPosition: 0,
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Port {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Port").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Port {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Port {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.Meta)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Meta {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.Meta.objectUUID)
    pub objectUUID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Meta.objectName)
    pub objectName: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Meta.parentUUID)
    pub parentUUID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Meta.position)
    pub position: ::protobuf::MessageField<Position>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.Meta.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Meta {
    fn default() -> &'a Meta {
        <Meta as ::protobuf::Message>::default_instance()
    }
}

impl Meta {
    pub fn new() -> Meta {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "objectUUID",
            |m: &Meta| { &m.objectUUID },
            |m: &mut Meta| { &mut m.objectUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "objectName",
            |m: &Meta| { &m.objectName },
            |m: &mut Meta| { &mut m.objectName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parentUUID",
            |m: &Meta| { &m.parentUUID },
            |m: &mut Meta| { &mut m.parentUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Position>(
            "position",
            |m: &Meta| { &m.position },
            |m: &mut Meta| { &mut m.position },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Meta>(
            "Meta",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Meta {
    const NAME: &'static str = "Meta";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.objectUUID = is.read_string()?;
                },
                18 => {
                    self.objectName = is.read_string()?;
                },
                26 => {
                    self.parentUUID = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.objectUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.objectUUID);
        }
        if !self.objectName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.objectName);
        }
        if !self.parentUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.parentUUID);
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.objectUUID.is_empty() {
            os.write_string(1, &self.objectUUID)?;
        }
        if !self.objectName.is_empty() {
            os.write_string(2, &self.objectName)?;
        }
        if !self.parentUUID.is_empty() {
            os.write_string(3, &self.parentUUID)?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Meta {
        Meta::new()
    }

    fn clear(&mut self) {
        self.objectUUID.clear();
        self.objectName.clear();
        self.parentUUID.clear();
        self.position.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Meta {
        static instance: Meta = Meta {
            objectUUID: ::std::string::String::new(),
            objectName: ::std::string::String::new(),
            parentUUID: ::std::string::String::new(),
            position: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Meta {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Meta").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Meta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Meta {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.Position)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Position {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.Position.positionY)
    pub positionY: i32,
    // @@protoc_insertion_point(field:App.Runtime.Position.positionX)
    pub positionX: i32,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.Position.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Position {
    fn default() -> &'a Position {
        <Position as ::protobuf::Message>::default_instance()
    }
}

impl Position {
    pub fn new() -> Position {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "positionY",
            |m: &Position| { &m.positionY },
            |m: &mut Position| { &mut m.positionY },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "positionX",
            |m: &Position| { &m.positionX },
            |m: &mut Position| { &mut m.positionX },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Position>(
            "Position",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Position {
    const NAME: &'static str = "Position";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.positionY = is.read_int32()?;
                },
                16 => {
                    self.positionX = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.positionY != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.positionY);
        }
        if self.positionX != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.positionX);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.positionY != 0 {
            os.write_int32(1, self.positionY)?;
        }
        if self.positionX != 0 {
            os.write_int32(2, self.positionX)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Position {
        Position::new()
    }

    fn clear(&mut self) {
        self.positionY = 0;
        self.positionX = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Position {
        static instance: Position = Position {
            positionY: 0,
            positionX: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Position {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Position").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Position {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Position {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.Connection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Connection {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.Connection.connectionUUID)
    pub connectionUUID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Connection.targetConnectionUUID)
    pub targetConnectionUUID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Connection.sourceUUID)
    pub sourceUUID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Connection.sourcePort)
    pub sourcePort: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Connection.sourcePortUUID)
    pub sourcePortUUID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Connection.targetUUID)
    pub targetUUID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Connection.targetPort)
    pub targetPort: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Connection.targetPortUUID)
    pub targetPortUUID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Connection.isExistingConnection)
    pub isExistingConnection: bool,
    // @@protoc_insertion_point(field:App.Runtime.Connection.flowDirection)
    pub flowDirection: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Connection.disable)
    pub disable: bool,
    // @@protoc_insertion_point(field:App.Runtime.Connection.isError)
    pub isError: bool,
    // @@protoc_insertion_point(field:App.Runtime.Connection.created)
    pub created: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Connection.lastOk)
    pub lastOk: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Connection.lastFail)
    pub lastFail: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.Connection.failCount)
    pub failCount: i32,
    // @@protoc_insertion_point(field:App.Runtime.Connection.error)
    pub error: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.Connection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Connection {
    fn default() -> &'a Connection {
        <Connection as ::protobuf::Message>::default_instance()
    }
}

impl Connection {
    pub fn new() -> Connection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "connectionUUID",
            |m: &Connection| { &m.connectionUUID },
            |m: &mut Connection| { &mut m.connectionUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "targetConnectionUUID",
            |m: &Connection| { &m.targetConnectionUUID },
            |m: &mut Connection| { &mut m.targetConnectionUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sourceUUID",
            |m: &Connection| { &m.sourceUUID },
            |m: &mut Connection| { &mut m.sourceUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sourcePort",
            |m: &Connection| { &m.sourcePort },
            |m: &mut Connection| { &mut m.sourcePort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sourcePortUUID",
            |m: &Connection| { &m.sourcePortUUID },
            |m: &mut Connection| { &mut m.sourcePortUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "targetUUID",
            |m: &Connection| { &m.targetUUID },
            |m: &mut Connection| { &mut m.targetUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "targetPort",
            |m: &Connection| { &m.targetPort },
            |m: &mut Connection| { &mut m.targetPort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "targetPortUUID",
            |m: &Connection| { &m.targetPortUUID },
            |m: &mut Connection| { &mut m.targetPortUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isExistingConnection",
            |m: &Connection| { &m.isExistingConnection },
            |m: &mut Connection| { &mut m.isExistingConnection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "flowDirection",
            |m: &Connection| { &m.flowDirection },
            |m: &mut Connection| { &mut m.flowDirection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disable",
            |m: &Connection| { &m.disable },
            |m: &mut Connection| { &mut m.disable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isError",
            |m: &Connection| { &m.isError },
            |m: &mut Connection| { &mut m.isError },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created",
            |m: &Connection| { &m.created },
            |m: &mut Connection| { &mut m.created },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lastOk",
            |m: &Connection| { &m.lastOk },
            |m: &mut Connection| { &mut m.lastOk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lastFail",
            |m: &Connection| { &m.lastFail },
            |m: &mut Connection| { &mut m.lastFail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "failCount",
            |m: &Connection| { &m.failCount },
            |m: &mut Connection| { &mut m.failCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "error",
            |m: &Connection| { &m.error },
            |m: &mut Connection| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Connection>(
            "Connection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Connection {
    const NAME: &'static str = "Connection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connectionUUID = is.read_string()?;
                },
                18 => {
                    self.targetConnectionUUID = is.read_string()?;
                },
                26 => {
                    self.sourceUUID = is.read_string()?;
                },
                34 => {
                    self.sourcePort = is.read_string()?;
                },
                42 => {
                    self.sourcePortUUID = is.read_string()?;
                },
                50 => {
                    self.targetUUID = is.read_string()?;
                },
                58 => {
                    self.targetPort = is.read_string()?;
                },
                66 => {
                    self.targetPortUUID = is.read_string()?;
                },
                72 => {
                    self.isExistingConnection = is.read_bool()?;
                },
                82 => {
                    self.flowDirection = is.read_string()?;
                },
                88 => {
                    self.disable = is.read_bool()?;
                },
                96 => {
                    self.isError = is.read_bool()?;
                },
                106 => {
                    self.created = is.read_string()?;
                },
                114 => {
                    self.lastOk = is.read_string()?;
                },
                122 => {
                    self.lastFail = is.read_string()?;
                },
                128 => {
                    self.failCount = is.read_int32()?;
                },
                138 => {
                    self.error.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.connectionUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.connectionUUID);
        }
        if !self.targetConnectionUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.targetConnectionUUID);
        }
        if !self.sourceUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.sourceUUID);
        }
        if !self.sourcePort.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.sourcePort);
        }
        if !self.sourcePortUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.sourcePortUUID);
        }
        if !self.targetUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.targetUUID);
        }
        if !self.targetPort.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.targetPort);
        }
        if !self.targetPortUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.targetPortUUID);
        }
        if self.isExistingConnection != false {
            my_size += 1 + 1;
        }
        if !self.flowDirection.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.flowDirection);
        }
        if self.disable != false {
            my_size += 1 + 1;
        }
        if self.isError != false {
            my_size += 1 + 1;
        }
        if !self.created.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.created);
        }
        if !self.lastOk.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.lastOk);
        }
        if !self.lastFail.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.lastFail);
        }
        if self.failCount != 0 {
            my_size += ::protobuf::rt::int32_size(16, self.failCount);
        }
        for value in &self.error {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.connectionUUID.is_empty() {
            os.write_string(1, &self.connectionUUID)?;
        }
        if !self.targetConnectionUUID.is_empty() {
            os.write_string(2, &self.targetConnectionUUID)?;
        }
        if !self.sourceUUID.is_empty() {
            os.write_string(3, &self.sourceUUID)?;
        }
        if !self.sourcePort.is_empty() {
            os.write_string(4, &self.sourcePort)?;
        }
        if !self.sourcePortUUID.is_empty() {
            os.write_string(5, &self.sourcePortUUID)?;
        }
        if !self.targetUUID.is_empty() {
            os.write_string(6, &self.targetUUID)?;
        }
        if !self.targetPort.is_empty() {
            os.write_string(7, &self.targetPort)?;
        }
        if !self.targetPortUUID.is_empty() {
            os.write_string(8, &self.targetPortUUID)?;
        }
        if self.isExistingConnection != false {
            os.write_bool(9, self.isExistingConnection)?;
        }
        if !self.flowDirection.is_empty() {
            os.write_string(10, &self.flowDirection)?;
        }
        if self.disable != false {
            os.write_bool(11, self.disable)?;
        }
        if self.isError != false {
            os.write_bool(12, self.isError)?;
        }
        if !self.created.is_empty() {
            os.write_string(13, &self.created)?;
        }
        if !self.lastOk.is_empty() {
            os.write_string(14, &self.lastOk)?;
        }
        if !self.lastFail.is_empty() {
            os.write_string(15, &self.lastFail)?;
        }
        if self.failCount != 0 {
            os.write_int32(16, self.failCount)?;
        }
        for v in &self.error {
            os.write_string(17, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Connection {
        Connection::new()
    }

    fn clear(&mut self) {
        self.connectionUUID.clear();
        self.targetConnectionUUID.clear();
        self.sourceUUID.clear();
        self.sourcePort.clear();
        self.sourcePortUUID.clear();
        self.targetUUID.clear();
        self.targetPort.clear();
        self.targetPortUUID.clear();
        self.isExistingConnection = false;
        self.flowDirection.clear();
        self.disable = false;
        self.isError = false;
        self.created.clear();
        self.lastOk.clear();
        self.lastFail.clear();
        self.failCount = 0;
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Connection {
        static instance: Connection = Connection {
            connectionUUID: ::std::string::String::new(),
            targetConnectionUUID: ::std::string::String::new(),
            sourceUUID: ::std::string::String::new(),
            sourcePort: ::std::string::String::new(),
            sourcePortUUID: ::std::string::String::new(),
            targetUUID: ::std::string::String::new(),
            targetPort: ::std::string::String::new(),
            targetPortUUID: ::std::string::String::new(),
            isExistingConnection: false,
            flowDirection: ::std::string::String::new(),
            disable: false,
            isError: false,
            created: ::std::string::String::new(),
            lastOk: ::std::string::String::new(),
            lastFail: ::std::string::String::new(),
            failCount: 0,
            error: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Connection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Connection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Connection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Connection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.ObjectExtractedDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObjectExtractedDetails {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.ObjectExtractedDetails.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectExtractedDetails.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectExtractedDetails.uuid)
    pub uuid: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectExtractedDetails.parentUUID)
    pub parentUUID: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectExtractedDetails.category)
    pub category: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectExtractedDetails.objectType)
    pub objectType: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectExtractedDetails.isParent)
    pub isParent: bool,
    // @@protoc_insertion_point(field:App.Runtime.ObjectExtractedDetails.children)
    pub children: ::std::vec::Vec<ObjectExtractedDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.ObjectExtractedDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObjectExtractedDetails {
    fn default() -> &'a ObjectExtractedDetails {
        <ObjectExtractedDetails as ::protobuf::Message>::default_instance()
    }
}

impl ObjectExtractedDetails {
    pub fn new() -> ObjectExtractedDetails {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ObjectExtractedDetails| { &m.id },
            |m: &mut ObjectExtractedDetails| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ObjectExtractedDetails| { &m.name },
            |m: &mut ObjectExtractedDetails| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uuid",
            |m: &ObjectExtractedDetails| { &m.uuid },
            |m: &mut ObjectExtractedDetails| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parentUUID",
            |m: &ObjectExtractedDetails| { &m.parentUUID },
            |m: &mut ObjectExtractedDetails| { &mut m.parentUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "category",
            |m: &ObjectExtractedDetails| { &m.category },
            |m: &mut ObjectExtractedDetails| { &mut m.category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "objectType",
            |m: &ObjectExtractedDetails| { &m.objectType },
            |m: &mut ObjectExtractedDetails| { &mut m.objectType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isParent",
            |m: &ObjectExtractedDetails| { &m.isParent },
            |m: &mut ObjectExtractedDetails| { &mut m.isParent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "children",
            |m: &ObjectExtractedDetails| { &m.children },
            |m: &mut ObjectExtractedDetails| { &mut m.children },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObjectExtractedDetails>(
            "ObjectExtractedDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObjectExtractedDetails {
    const NAME: &'static str = "ObjectExtractedDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.uuid = is.read_string()?;
                },
                34 => {
                    self.parentUUID = is.read_string()?;
                },
                42 => {
                    self.category = is.read_string()?;
                },
                50 => {
                    self.objectType = is.read_string()?;
                },
                56 => {
                    self.isParent = is.read_bool()?;
                },
                66 => {
                    self.children.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.uuid);
        }
        if !self.parentUUID.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.parentUUID);
        }
        if !self.category.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.category);
        }
        if !self.objectType.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.objectType);
        }
        if self.isParent != false {
            my_size += 1 + 1;
        }
        for value in &self.children {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.uuid.is_empty() {
            os.write_string(3, &self.uuid)?;
        }
        if !self.parentUUID.is_empty() {
            os.write_string(4, &self.parentUUID)?;
        }
        if !self.category.is_empty() {
            os.write_string(5, &self.category)?;
        }
        if !self.objectType.is_empty() {
            os.write_string(6, &self.objectType)?;
        }
        if self.isParent != false {
            os.write_bool(7, self.isParent)?;
        }
        for v in &self.children {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObjectExtractedDetails {
        ObjectExtractedDetails::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.uuid.clear();
        self.parentUUID.clear();
        self.category.clear();
        self.objectType.clear();
        self.isParent = false;
        self.children.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObjectExtractedDetails {
        static instance: ObjectExtractedDetails = ObjectExtractedDetails {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            uuid: ::std::string::String::new(),
            parentUUID: ::std::string::String::new(),
            category: ::std::string::String::new(),
            objectType: ::std::string::String::new(),
            isParent: false,
            children: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObjectExtractedDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObjectExtractedDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObjectExtractedDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectExtractedDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:App.Runtime.ObjectsRootMap)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObjectsRootMap {
    // message fields
    // @@protoc_insertion_point(field:App.Runtime.ObjectsRootMap.rubixNetworkName)
    pub rubixNetworkName: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectsRootMap.rubixNetworkDesc)
    pub rubixNetworkDesc: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectsRootMap.rubixNetwork)
    pub rubixNetwork: ::std::vec::Vec<ObjectExtractedDetails>,
    // @@protoc_insertion_point(field:App.Runtime.ObjectsRootMap.driversName)
    pub driversName: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectsRootMap.driversDesc)
    pub driversDesc: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectsRootMap.drivers)
    pub drivers: ::std::vec::Vec<ObjectExtractedDetails>,
    // @@protoc_insertion_point(field:App.Runtime.ObjectsRootMap.servicesName)
    pub servicesName: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectsRootMap.servicesDesc)
    pub servicesDesc: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectsRootMap.services)
    pub services: ::std::vec::Vec<ObjectExtractedDetails>,
    // @@protoc_insertion_point(field:App.Runtime.ObjectsRootMap.logicName)
    pub logicName: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectsRootMap.logicDesc)
    pub logicDesc: ::std::string::String,
    // @@protoc_insertion_point(field:App.Runtime.ObjectsRootMap.logic)
    pub logic: ::std::vec::Vec<ObjectExtractedDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:App.Runtime.ObjectsRootMap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObjectsRootMap {
    fn default() -> &'a ObjectsRootMap {
        <ObjectsRootMap as ::protobuf::Message>::default_instance()
    }
}

impl ObjectsRootMap {
    pub fn new() -> ObjectsRootMap {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rubixNetworkName",
            |m: &ObjectsRootMap| { &m.rubixNetworkName },
            |m: &mut ObjectsRootMap| { &mut m.rubixNetworkName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rubixNetworkDesc",
            |m: &ObjectsRootMap| { &m.rubixNetworkDesc },
            |m: &mut ObjectsRootMap| { &mut m.rubixNetworkDesc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rubixNetwork",
            |m: &ObjectsRootMap| { &m.rubixNetwork },
            |m: &mut ObjectsRootMap| { &mut m.rubixNetwork },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "driversName",
            |m: &ObjectsRootMap| { &m.driversName },
            |m: &mut ObjectsRootMap| { &mut m.driversName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "driversDesc",
            |m: &ObjectsRootMap| { &m.driversDesc },
            |m: &mut ObjectsRootMap| { &mut m.driversDesc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "drivers",
            |m: &ObjectsRootMap| { &m.drivers },
            |m: &mut ObjectsRootMap| { &mut m.drivers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "servicesName",
            |m: &ObjectsRootMap| { &m.servicesName },
            |m: &mut ObjectsRootMap| { &mut m.servicesName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "servicesDesc",
            |m: &ObjectsRootMap| { &m.servicesDesc },
            |m: &mut ObjectsRootMap| { &mut m.servicesDesc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "services",
            |m: &ObjectsRootMap| { &m.services },
            |m: &mut ObjectsRootMap| { &mut m.services },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "logicName",
            |m: &ObjectsRootMap| { &m.logicName },
            |m: &mut ObjectsRootMap| { &mut m.logicName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "logicDesc",
            |m: &ObjectsRootMap| { &m.logicDesc },
            |m: &mut ObjectsRootMap| { &mut m.logicDesc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "logic",
            |m: &ObjectsRootMap| { &m.logic },
            |m: &mut ObjectsRootMap| { &mut m.logic },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObjectsRootMap>(
            "ObjectsRootMap",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObjectsRootMap {
    const NAME: &'static str = "ObjectsRootMap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rubixNetworkName = is.read_string()?;
                },
                18 => {
                    self.rubixNetworkDesc = is.read_string()?;
                },
                26 => {
                    self.rubixNetwork.push(is.read_message()?);
                },
                34 => {
                    self.driversName = is.read_string()?;
                },
                42 => {
                    self.driversDesc = is.read_string()?;
                },
                50 => {
                    self.drivers.push(is.read_message()?);
                },
                58 => {
                    self.servicesName = is.read_string()?;
                },
                66 => {
                    self.servicesDesc = is.read_string()?;
                },
                74 => {
                    self.services.push(is.read_message()?);
                },
                82 => {
                    self.logicName = is.read_string()?;
                },
                90 => {
                    self.logicDesc = is.read_string()?;
                },
                98 => {
                    self.logic.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.rubixNetworkName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rubixNetworkName);
        }
        if !self.rubixNetworkDesc.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.rubixNetworkDesc);
        }
        for value in &self.rubixNetwork {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.driversName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.driversName);
        }
        if !self.driversDesc.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.driversDesc);
        }
        for value in &self.drivers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.servicesName.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.servicesName);
        }
        if !self.servicesDesc.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.servicesDesc);
        }
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.logicName.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.logicName);
        }
        if !self.logicDesc.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.logicDesc);
        }
        for value in &self.logic {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.rubixNetworkName.is_empty() {
            os.write_string(1, &self.rubixNetworkName)?;
        }
        if !self.rubixNetworkDesc.is_empty() {
            os.write_string(2, &self.rubixNetworkDesc)?;
        }
        for v in &self.rubixNetwork {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.driversName.is_empty() {
            os.write_string(4, &self.driversName)?;
        }
        if !self.driversDesc.is_empty() {
            os.write_string(5, &self.driversDesc)?;
        }
        for v in &self.drivers {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if !self.servicesName.is_empty() {
            os.write_string(7, &self.servicesName)?;
        }
        if !self.servicesDesc.is_empty() {
            os.write_string(8, &self.servicesDesc)?;
        }
        for v in &self.services {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if !self.logicName.is_empty() {
            os.write_string(10, &self.logicName)?;
        }
        if !self.logicDesc.is_empty() {
            os.write_string(11, &self.logicDesc)?;
        }
        for v in &self.logic {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObjectsRootMap {
        ObjectsRootMap::new()
    }

    fn clear(&mut self) {
        self.rubixNetworkName.clear();
        self.rubixNetworkDesc.clear();
        self.rubixNetwork.clear();
        self.driversName.clear();
        self.driversDesc.clear();
        self.drivers.clear();
        self.servicesName.clear();
        self.servicesDesc.clear();
        self.services.clear();
        self.logicName.clear();
        self.logicDesc.clear();
        self.logic.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObjectsRootMap {
        static instance: ObjectsRootMap = ObjectsRootMap {
            rubixNetworkName: ::std::string::String::new(),
            rubixNetworkDesc: ::std::string::String::new(),
            rubixNetwork: ::std::vec::Vec::new(),
            driversName: ::std::string::String::new(),
            driversDesc: ::std::string::String::new(),
            drivers: ::std::vec::Vec::new(),
            servicesName: ::std::string::String::new(),
            servicesDesc: ::std::string::String::new(),
            services: ::std::vec::Vec::new(),
            logicName: ::std::string::String::new(),
            logicDesc: ::std::string::String::new(),
            logic: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObjectsRootMap {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObjectsRootMap").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObjectsRootMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectsRootMap {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rruntime.proto\x12\x0bApp.Runtime\x1a\x1cgoogle/api/annotations.proto\
    \"\xe0\x01\n\x0eMessageRequest\x12\x12\n\x04uuid\x18\x01\x20\x01(\tR\x04\
    uuid\x12\x10\n\x03key\x18\x02\x20\x01(\tR\x03key\x121\n\x06object\x18\
    \x03\x20\x01(\x0b2\x19.App.Runtime.ObjectConfigR\x06object\x121\n\x06pal\
    let\x18\x04\x20\x03(\x0b2\x19.App.Runtime.ObjectConfigR\x06pallet\x12\
    \x12\n\x04body\x18\x05\x20\x01(\x0cR\x04body\x12.\n\x07command\x18\x06\
    \x20\x01(\x0b2\x14.App.Runtime.CommandR\x07command\"g\n\nPluginInfo\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04uuid\x18\x02\x20\
    \x01(\tR\x04uuid\x121\n\x06pallet\x18\x04\x20\x03(\x0b2\x19.App.Runtime.\
    ObjectConfigR\x06pallet\"*\n\x0ePluginResponse\x12\x18\n\x07message\x18\
    \x01\x20\x01(\tR\x07message\"?\n\nPluginList\x121\n\x07plugins\x18\x01\
    \x20\x03(\x0b2\x17.App.Runtime.PluginInfoR\x07plugins\"\xc6\x01\n\x18Get\
    ObjectsValuesResponse\x12I\n\x06values\x18\x01\x20\x03(\x0b21.App.Runtim\
    e.GetObjectsValuesResponse.ValuesEntryR\x06values\x1a_\n\x0bValuesEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12:\n\x05value\x18\x02\x20\
    \x01(\x0b2$.App.Runtime.GetObjectValuesResponseR\x05value:\x028\x01\"I\n\
    \x17GetObjectValuesResponse\x12.\n\x06values\x18\x01\x20\x03(\x0b2\x16.A\
    pp.Runtime.PortValueR\x06values\"0\n\x14ObjectsValuesRequest\x12\x18\n\
    \x07asBytes\x18\x02\x20\x01(\x08R\x07asBytes\"C\n\x13ObjectsValueRequest\
    \x12\x12\n\x04uuid\x18\x01\x20\x01(\tR\x04uuid\x12\x18\n\x07asBytes\x18\
    \x02\x20\x01(\x08R\x07asBytes\"E\n\x0bPortRequest\x12\x1e\n\nobjectUUID\
    \x18\x01\x20\x01(\tR\nobjectUUID\x12\x16\n\x06portID\x18\x02\x20\x01(\tR\
    \x06portID\"\x9b\x02\n\tPortValue\x12\x16\n\x06portID\x18\x01\x20\x01(\t\
    R\x06portID\x12\x1a\n\x08dataType\x18\x02\x20\x01(\tR\x08dataType\x12\
    \x14\n\x05isNil\x18\x03\x20\x01(\x08R\x05isNil\x124\n\x15transformationA\
    pplied\x18\x04\x20\x01(\x08R\x15transformationApplied\x12\x12\n\x04data\
    \x18\x05\x20\x01(\x0cR\x04data\x12\x16\n\x06number\x18\x06\x20\x01(\x01R\
    \x06number\x12H\n\x0etransformation\x18\x07\x20\x01(\x0b2\x20.App.Runtim\
    e.ValueTransformationR\x0etransformation\x12\x18\n\x07portIDs\x18\x08\
    \x20\x03(\tR\x07portIDs\"C\n\x13ValueTransformation\x12\x12\n\x04unit\
    \x18\x01\x20\x01(\tR\x04unit\x12\x18\n\x07rawData\x18\x02\x20\x01(\x0cR\
    \x07rawData\",\n\x0eObjectsRequest\x12\x1a\n\x08withData\x18\x01\x20\x01\
    (\x08R\x08withData\"\x0f\n\rPalletRequest\"\x9d\x01\n\nPalletTree\x12>\n\
    \x07plugins\x18\x01\x20\x03(\x0b2$.App.Runtime.PalletTree.PluginsEntryR\
    \x07plugins\x1aO\n\x0cPluginsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12)\n\x05value\x18\x02\x20\x01(\x0b2\x13.App.Runtime.PluginR\
    \x05value:\x028\x01\"\xd8\x03\n\x06Plugin\x12:\n\x07drivers\x18\x01\x20\
    \x03(\x0b2\x20.App.Runtime.Plugin.DriversEntryR\x07drivers\x124\n\x05log\
    ic\x18\x02\x20\x03(\x0b2\x1e.App.Runtime.Plugin.LogicEntryR\x05logic\x12\
    =\n\x08services\x18\x03\x20\x03(\x0b2!.App.Runtime.Plugin.ServicesEntryR\
    \x08services\x1a^\n\x0cDriversEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x128\n\x05value\x18\x02\x20\x01(\x0b2\".App.Runtime.NestedObject\
    ConfigMapR\x05value:\x028\x01\x1a\\\n\nLogicEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x128\n\x05value\x18\x02\x20\x01(\x0b2\".App.Runt\
    ime.NestedObjectConfigMapR\x05value:\x028\x01\x1a_\n\rServicesEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x128\n\x05value\x18\x02\x20\x01\
    (\x0b2\".App.Runtime.NestedObjectConfigMapR\x05value:\x028\x01\"\xb9\x01\
    \n\x15NestedObjectConfigMap\x12I\n\x07entries\x18\x01\x20\x03(\x0b2/.App\
    .Runtime.NestedObjectConfigMap.EntriesEntryR\x07entries\x1aU\n\x0cEntrie\
    sEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12/\n\x05value\x18\
    \x02\x20\x01(\x0b2\x19.App.Runtime.ObjectConfigR\x05value:\x028\x01\"\
    \x83\x04\n\x07Command\x12&\n\x0etargetGlobalID\x18\x01\x20\x01(\tR\x0eta\
    rgetGlobalID\x12&\n\x0esenderGlobalID\x18\x02\x20\x01(\tR\x0esenderGloba\
    lID\x12*\n\x10targetObjectUUID\x18\x03\x20\x01(\tR\x10targetObjectUUID\
    \x12*\n\x10senderObjectUUID\x18\x04\x20\x01(\tR\x10senderObjectUUID\x12(\
    \n\x0ftransactionUUID\x18\x05\x20\x01(\tR\x0ftransactionUUID\x12\x10\n\
    \x03key\x18\x06\x20\x01(\tR\x03key\x12\x14\n\x05query\x18\x07\x20\x01(\t\
    R\x05query\x12\x12\n\x04args\x18\x08\x20\x03(\tR\x04args\x122\n\x04data\
    \x18\t\x20\x03(\x0b2\x1e.App.Runtime.Command.DataEntryR\x04data\x12\x12\
    \n\x04body\x18\n\x20\x01(\x0cR\x04body\x121\n\x06object\x18\x0b\x20\x01(\
    \x0b2\x19.App.Runtime.ObjectConfigR\x06object\x126\n\nportValues\x18\x0c\
    \x20\x03(\x0b2\x16.App.Runtime.PortValueR\nportValues\x1a7\n\tDataEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\"\xcb\x03\n\x0fCommandResponse\x12\x1a\n\
    \x08senderID\x18\x01\x20\x01(\tR\x08senderID\x12\x14\n\x05count\x18\x02\
    \x20\x01(\x05R\x05count\x12L\n\nmapStrings\x18\x03\x20\x03(\x0b2,.App.Ru\
    ntime.CommandResponse.MapStringsEntryR\nmapStrings\x12\x16\n\x06number\
    \x18\x04\x20\x01(\x01R\x06number\x12\x18\n\x07boolean\x18\x05\x20\x01(\
    \x08R\x07boolean\x12\x14\n\x05error\x18\x06\x20\x01(\tR\x05error\x12\x1e\
    \n\nreturnType\x18\x07\x20\x01(\tR\nreturnType\x12\x10\n\x03any\x18\x08\
    \x20\x01(\x0cR\x03any\x128\n\x08response\x18\t\x20\x03(\x0b2\x1c.App.Run\
    time.CommandResponseR\x08response\x12E\n\x10serializeObjects\x18\n\x20\
    \x03(\x0b2\x19.App.Runtime.ObjectConfigR\x10serializeObjects\x1a=\n\x0fM\
    apStringsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05\
    value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\r\n\x0bPingRequest\"(\n\
    \x0cPingResponse\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\"\
    \x8a\x01\n\x0cObjectDeploy\x12\x18\n\x07deleted\x18\x01\x20\x03(\tR\x07d\
    eleted\x12+\n\x03new\x18\x02\x20\x03(\x0b2\x19.App.Runtime.ObjectConfigR\
    \x03new\x123\n\x07updated\x18\x03\x20\x03(\x0b2\x19.App.Runtime.ObjectCo\
    nfigR\x07updated\"\x07\n\x05Empty\"F\n\x0fObjectsResponse\x123\n\x07obje\
    cts\x18\x01\x20\x03(\x0b2\x19.App.Runtime.ObjectConfigR\x07objects\"C\n\
    \rObjectRequest\x12\x12\n\x04uuid\x18\x01\x20\x01(\tR\x04uuid\x12\x1e\n\
    \nwithPoints\x18\x02\x20\x01(\x08R\nwithPoints\"\xe2\x02\n\x0cObjectConf\
    ig\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12%\n\x04info\x18\x02\x20\
    \x01(\x0b2\x11.App.Runtime.InfoR\x04info\x12)\n\x06inputs\x18\x03\x20\
    \x03(\x0b2\x11.App.Runtime.PortR\x06inputs\x12+\n\x07outputs\x18\x04\x20\
    \x03(\x0b2\x11.App.Runtime.PortR\x07outputs\x12%\n\x04meta\x18\x05\x20\
    \x01(\x0b2\x11.App.Runtime.MetaR\x04meta\x12.\n\x05stats\x18\x06\x20\x01\
    (\x0b2\x18.App.Runtime.ObjectStatsR\x05stats\x129\n\x0bconnections\x18\
    \x07\x20\x03(\x0b2\x17.App.Runtime.ConnectionR\x0bconnections\x121\n\x08\
    settings\x18\x08\x20\x01(\x0b2\x15.App.Runtime.SettingsR\x08settings\"\
    \x20\n\x08Settings\x12\x14\n\x05value\x18\x01\x20\x01(\x0cR\x05value\"\
    \x8b\x04\n\x04Info\x12\x1a\n\x08objectID\x18\x01\x20\x01(\tR\x08objectID\
    \x12\x1e\n\nobjectType\x18\x02\x20\x01(\tR\nobjectType\x12\x1a\n\x08cate\
    gory\x18\x03\x20\x01(\tR\x08category\x12\x1e\n\npluginName\x18\x04\x20\
    \x01(\tR\npluginName\x12\"\n\x0cworkingGroup\x18\x05\x20\x01(\tR\x0cwork\
    ingGroup\x12.\n\x12workingGroupLeader\x18\x06\x20\x01(\tR\x12workingGrou\
    pLeader\x12.\n\x12workingGroupParent\x18\x07\x20\x01(\tR\x12workingGroup\
    Parent\x120\n\x13workingGroupObjects\x18\x08\x20\x03(\tR\x13workingGroup\
    Objects\x12:\n\x18workingGroupChildObjects\x18\t\x20\x03(\tR\x18workingG\
    roupChildObjects\x12\x1e\n\nobjectTags\x18\n\x20\x03(\tR\nobjectTags\x12\
    :\n\x0bpermissions\x18\x0b\x20\x01(\x0b2\x18.App.Runtime.PermissionsR\
    \x0bpermissions\x12=\n\x0crequirements\x18\x0c\x20\x01(\x0b2\x19.App.Run\
    time.RequirementsR\x0crequirements\"\x81\x02\n\x0bPermissions\x12&\n\x0e\
    allPermissions\x18\x01\x20\x01(\x08R\x0eallPermissions\x12\"\n\x0ccanBeC\
    reated\x18\x02\x20\x01(\x08R\x0ccanBeCreated\x12\"\n\x0ccanBeDeleted\x18\
    \x03\x20\x01(\x08R\x0ccanBeDeleted\x12\"\n\x0ccanBeUpdated\x18\x04\x20\
    \x01(\x08R\x0ccanBeUpdated\x12\x1a\n\x08readOnly\x18\x05\x20\x01(\x08R\
    \x08readOnly\x12\x20\n\x0ballowHotFix\x18\x06\x20\x01(\x08R\x0ballowHotF\
    ix\x12\x20\n\x0bforceDelete\x18\x07\x20\x01(\x08R\x0bforceDelete\"\x8c\
    \x03\n\x0cRequirements\x12,\n\x11callResetOnDeploy\x18\x01\x20\x01(\x08R\
    \x11callResetOnDeploy\x12.\n\x12allowRuntimeAccess\x18\x02\x20\x01(\x08R\
    \x12allowRuntimeAccess\x12\x16\n\x06maxOne\x18\x03\x20\x01(\x08R\x06maxO\
    ne\x122\n\x14mustLiveInObjectType\x18\x04\x20\x01(\x08R\x14mustLiveInObj\
    ectType\x12&\n\x0emustLiveParent\x18\x05\x20\x01(\x08R\x0emustLiveParent\
    \x12&\n\x0erequiresLogger\x18\x06\x20\x01(\x08R\x0erequiresLogger\x12(\n\
    \x0fsupportsActions\x18\x07\x20\x01(\x08R\x0fsupportsActions\x122\n\x14s\
    ervicesRequirements\x18\x08\x20\x03(\tR\x14servicesRequirements\x12$\n\r\
    loggerOptions\x18\t\x20\x03(\tR\rloggerOptions\"y\n\x0bObjectStats\x12\
    \x16\n\x06status\x18\x01\x20\x01(\tR\x06status\x12\x16\n\x06loaded\x18\
    \x02\x20\x01(\tR\x06loaded\x12\x1c\n\tloopCount\x18\x03\x20\x01(\rR\tloo\
    pCount\x12\x1c\n\ttimeSince\x18\x06\x20\x01(\tR\ttimeSince\"\xc0\x01\n\
    \x04Port\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\
    \x02\x20\x01(\tR\x04name\x12\x1a\n\x08portUUID\x18\x03\x20\x01(\tR\x08po\
    rtUUID\x12\x1c\n\tdirection\x18\x04\x20\x01(\tR\tdirection\x12\x1a\n\x08\
    dataType\x18\x05\x20\x01(\tR\x08dataType\x12(\n\x0fdefaultPosition\x18\
    \x06\x20\x01(\x05R\x0fdefaultPosition\x12\x14\n\x05value\x18\x07\x20\x01\
    (\tR\x05value\"\x99\x01\n\x04Meta\x12\x1e\n\nobjectUUID\x18\x01\x20\x01(\
    \tR\nobjectUUID\x12\x1e\n\nobjectName\x18\x02\x20\x01(\tR\nobjectName\
    \x12\x1e\n\nparentUUID\x18\x03\x20\x01(\tR\nparentUUID\x121\n\x08positio\
    n\x18\x04\x20\x01(\x0b2\x15.App.Runtime.PositionR\x08position\"F\n\x08Po\
    sition\x12\x1c\n\tpositionY\x18\x01\x20\x01(\x05R\tpositionY\x12\x1c\n\t\
    positionX\x18\x02\x20\x01(\x05R\tpositionX\"\xc8\x04\n\nConnection\x12&\
    \n\x0econnectionUUID\x18\x01\x20\x01(\tR\x0econnectionUUID\x122\n\x14tar\
    getConnectionUUID\x18\x02\x20\x01(\tR\x14targetConnectionUUID\x12\x1e\n\
    \nsourceUUID\x18\x03\x20\x01(\tR\nsourceUUID\x12\x1e\n\nsourcePort\x18\
    \x04\x20\x01(\tR\nsourcePort\x12&\n\x0esourcePortUUID\x18\x05\x20\x01(\t\
    R\x0esourcePortUUID\x12\x1e\n\ntargetUUID\x18\x06\x20\x01(\tR\ntargetUUI\
    D\x12\x1e\n\ntargetPort\x18\x07\x20\x01(\tR\ntargetPort\x12&\n\x0etarget\
    PortUUID\x18\x08\x20\x01(\tR\x0etargetPortUUID\x122\n\x14isExistingConne\
    ction\x18\t\x20\x01(\x08R\x14isExistingConnection\x12$\n\rflowDirection\
    \x18\n\x20\x01(\tR\rflowDirection\x12\x18\n\x07disable\x18\x0b\x20\x01(\
    \x08R\x07disable\x12\x18\n\x07isError\x18\x0c\x20\x01(\x08R\x07isError\
    \x12\x18\n\x07created\x18\r\x20\x01(\tR\x07created\x12\x16\n\x06lastOk\
    \x18\x0e\x20\x01(\tR\x06lastOk\x12\x1a\n\x08lastFail\x18\x0f\x20\x01(\tR\
    \x08lastFail\x12\x1c\n\tfailCount\x18\x10\x20\x01(\x05R\tfailCount\x12\
    \x14\n\x05error\x18\x11\x20\x03(\tR\x05error\"\x89\x02\n\x16ObjectExtrac\
    tedDetails\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04uuid\x18\x03\x20\x01(\tR\x04uu\
    id\x12\x1e\n\nparentUUID\x18\x04\x20\x01(\tR\nparentUUID\x12\x1a\n\x08ca\
    tegory\x18\x05\x20\x01(\tR\x08category\x12\x1e\n\nobjectType\x18\x06\x20\
    \x01(\tR\nobjectType\x12\x1a\n\x08isParent\x18\x07\x20\x01(\x08R\x08isPa\
    rent\x12?\n\x08children\x18\x08\x20\x03(\x0b2#.App.Runtime.ObjectExtract\
    edDetailsR\x08children\"\xb4\x04\n\x0eObjectsRootMap\x12*\n\x10rubixNetw\
    orkName\x18\x01\x20\x01(\tR\x10rubixNetworkName\x12*\n\x10rubixNetworkDe\
    sc\x18\x02\x20\x01(\tR\x10rubixNetworkDesc\x12G\n\x0crubixNetwork\x18\
    \x03\x20\x03(\x0b2#.App.Runtime.ObjectExtractedDetailsR\x0crubixNetwork\
    \x12\x20\n\x0bdriversName\x18\x04\x20\x01(\tR\x0bdriversName\x12\x20\n\
    \x0bdriversDesc\x18\x05\x20\x01(\tR\x0bdriversDesc\x12=\n\x07drivers\x18\
    \x06\x20\x03(\x0b2#.App.Runtime.ObjectExtractedDetailsR\x07drivers\x12\"\
    \n\x0cservicesName\x18\x07\x20\x01(\tR\x0cservicesName\x12\"\n\x0cservic\
    esDesc\x18\x08\x20\x01(\tR\x0cservicesDesc\x12?\n\x08services\x18\t\x20\
    \x03(\x0b2#.App.Runtime.ObjectExtractedDetailsR\x08services\x12\x1c\n\tl\
    ogicName\x18\n\x20\x01(\tR\tlogicName\x12\x1c\n\tlogicDesc\x18\x0b\x20\
    \x01(\tR\tlogicDesc\x129\n\x05logic\x18\x0c\x20\x03(\x0b2#.App.Runtime.O\
    bjectExtractedDetailsR\x05logic2\xd6\r\n\x0eRuntimeService\x12]\n\nGetOb\
    jects\x12\x1b.App.Runtime.ObjectsRequest\x1a\x1c.App.Runtime.ObjectsResp\
    onse\"\x14\x82\xd3\xe4\x93\x02\x0e\x12\x0c/api/runtime\x12g\n\tGetObject\
    \x12\x1a.App.Runtime.ObjectRequest\x1a\x19.App.Runtime.ObjectConfig\"#\
    \x82\xd3\xe4\x93\x02\x1d\x12\x1b/api/runtime/objects/{uuid}\x12e\n\x0eGe\
    tTreeMapRoot\x12\x1b.App.Runtime.ObjectsRequest\x1a\x1b.App.Runtime.Obje\
    ctsRootMap\"\x19\x82\xd3\xe4\x93\x02\x13\x12\x11/api/runtime/tree\x12a\n\
    \rGetPalletTree\x12\x1a.App.Runtime.PalletRequest\x1a\x17.App.Runtime.Pa\
    lletTree\"\x1b\x82\xd3\xe4\x93\x02\x15\x12\x13/api/plugins/pallet\x12^\n\
    \rObjectsDeploy\x12\x19.App.Runtime.ObjectDeploy\x1a\x19.App.Runtime.Obj\
    ectDeploy\"\x17\x82\xd3\xe4\x93\x02\x11\"\x0c/api/runtime:\x01*\x12N\n\
    \x04Ping\x12\x18.App.Runtime.PingRequest\x1a\x19.App.Runtime.PingRespons\
    e\"\x11\x82\xd3\xe4\x93\x02\x0b\x12\t/api/ping\x12\\\n\rObjectCommand\
    \x12\x14.App.Runtime.Command\x1a\x1c.App.Runtime.CommandResponse\"\x17\
    \x82\xd3\xe4\x93\x02\x11\"\x0c/api/command:\x01*\x12Z\n\x0cObjectInvoke\
    \x12\x14.App.Runtime.Command\x1a\x1c.App.Runtime.CommandResponse\"\x16\
    \x82\xd3\xe4\x93\x02\x10\"\x0b/api/invoke:\x01*\x12\x81\x01\n\x10GetObje\
    ctsValues\x12!.App.Runtime.ObjectsValuesRequest\x1a%.App.Runtime.GetObje\
    ctsValuesResponse\"#\x82\xd3\xe4\x93\x02\x1d\x12\x1b/api/runtime/objects\
    /values\x12\x85\x01\n\x0fGetObjectValues\x12\x20.App.Runtime.ObjectsValu\
    eRequest\x1a$.App.Runtime.GetObjectValuesResponse\"*\x82\xd3\xe4\x93\x02\
    $\x12\"/api/runtime/objects/values/{uuid}\x12y\n\x0cGetPortValue\x12\x18\
    .App.Runtime.PortRequest\x1a\x16.App.Runtime.PortValue\"7\x82\xd3\xe4\
    \x93\x021\x12//api/runtime/objects/{objectUUID}/port/{portID}\x12h\n\x0e\
    RegisterPlugin\x12\x17.App.Runtime.PluginInfo\x1a\x1b.App.Runtime.Plugin\
    Response\"\x20\x82\xd3\xe4\x93\x02\x1a\"\x15/api/plugins/register:\x01*\
    \x12l\n\x10DeregisterPlugin\x12\x17.App.Runtime.PluginInfo\x1a\x1b.App.R\
    untime.PluginResponse\"\"\x82\xd3\xe4\x93\x02\x1c\"\x17/api/plugins/dere\
    gister:\x01*\x12U\n\x0bListPlugins\x12\x12.App.Runtime.Empty\x1a\x17.App\
    .Runtime.PluginList\"\x19\x82\xd3\xe4\x93\x02\x13\x12\x11/api/plugins/li\
    st\x12g\n\nPingPlugin\x12\x17.App.Runtime.PluginInfo\x1a\x1b.App.Runtime\
    .PluginResponse\"#\x82\xd3\xe4\x93\x02\x1d\"\x18/api/plugins/ping/{uuid}\
    :\x01*\x12S\n\nGetPlugins\x12\x12.App.Runtime.Empty\x1a\x17.App.Runtime.\
    PluginList\"\x18\x82\xd3\xe4\x93\x02\x12\x12\x10/api/plugins/get\x12T\n\
    \x14PluginStreamMessages\x12\x1b.App.Runtime.MessageRequest\x1a\x1b.App.\
    Runtime.MessageRequest(\x010\x01B\x0cZ\n./;runtimeJ\x9f_\n\x07\x12\x05\0\
    \0\x94\x03\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x08\x12\x03\
    \x02\0!\n\t\n\x02\x08\x0b\x12\x03\x02\0!\n\x08\n\x01\x02\x12\x03\x04\0\
    \x14\n\t\n\x02\x03\0\x12\x03\x05\0&\n\n\n\x02\x06\0\x12\x04\x08\0y\x01\n\
    \n\n\x03\x06\0\x01\x12\x03\x08\x08\x16\n\x0c\n\x04\x06\0\x02\0\x12\x04\n\
    \x02\x0e\x03\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\n\x06\x10\n\x0c\n\x05\
    \x06\0\x02\0\x02\x12\x03\n\x12\x20\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\n\
    +:\n\r\n\x05\x06\0\x02\0\x04\x12\x04\x0b\x04\r\x06\n\x11\n\t\x06\0\x02\0\
    \x04\xb0\xca\xbc\"\x12\x04\x0b\x04\r\x06\n\x0c\n\x04\x06\0\x02\x01\x12\
    \x04\x10\x02\x14\x03\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\x10\x06\x0f\n\
    \x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x10\x11\x1e\n\x0c\n\x05\x06\0\x02\
    \x01\x03\x12\x03\x10)5\n\r\n\x05\x06\0\x02\x01\x04\x12\x04\x11\x04\x13\
    \x06\n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\x04\x11\x04\x13\x06\n\
    \x0c\n\x04\x06\0\x02\x02\x12\x04\x16\x02\x1a\x03\n\x0c\n\x05\x06\0\x02\
    \x02\x01\x12\x03\x16\x06\x14\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\x16\
    \x16$\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\x16/=\n\r\n\x05\x06\0\x02\
    \x02\x04\x12\x04\x17\x04\x19\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\
    \"\x12\x04\x17\x04\x19\x06\n\x0c\n\x04\x06\0\x02\x03\x12\x04\x1c\x02\x20\
    \x03\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03\x1c\x06\x13\n\x0c\n\x05\x06\0\
    \x02\x03\x02\x12\x03\x1c\x15\"\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\x1c\
    -7\n\r\n\x05\x06\0\x02\x03\x04\x12\x04\x1d\x04\x1f\x06\n\x11\n\t\x06\0\
    \x02\x03\x04\xb0\xca\xbc\"\x12\x04\x1d\x04\x1f\x06\n\x0c\n\x04\x06\0\x02\
    \x04\x12\x04#\x02(\x03\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03#\x06\x13\n\
    \x0c\n\x05\x06\0\x02\x04\x02\x12\x03#\x15!\n\x0c\n\x05\x06\0\x02\x04\x03\
    \x12\x03#,8\n\r\n\x05\x06\0\x02\x04\x04\x12\x04$\x04'\x06\n\x11\n\t\x06\
    \0\x02\x04\x04\xb0\xca\xbc\"\x12\x04$\x04'\x06\n\x0c\n\x04\x06\0\x02\x05\
    \x12\x04*\x02.\x03\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03*\x06\n\n\x0c\n\
    \x05\x06\0\x02\x05\x02\x12\x03*\x0c\x17\n\x0c\n\x05\x06\0\x02\x05\x03\
    \x12\x03*\".\n\r\n\x05\x06\0\x02\x05\x04\x12\x04+\x04-\x06\n\x11\n\t\x06\
    \0\x02\x05\x04\xb0\xca\xbc\"\x12\x04+\x04-\x06\n\x0c\n\x04\x06\0\x02\x06\
    \x12\x040\x025\x03\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x030\x06\x13\n\x0c\
    \n\x05\x06\0\x02\x06\x02\x12\x030\x15\x1c\n\x0c\n\x05\x06\0\x02\x06\x03\
    \x12\x030'6\n\r\n\x05\x06\0\x02\x06\x04\x12\x041\x044\x06\n\x11\n\t\x06\
    \0\x02\x06\x04\xb0\xca\xbc\"\x12\x041\x044\x06\n\x0c\n\x04\x06\0\x02\x07\
    \x12\x047\x02<\x03\n\x0c\n\x05\x06\0\x02\x07\x01\x12\x037\x06\x12\n\x0c\
    \n\x05\x06\0\x02\x07\x02\x12\x037\x14\x1b\n\x0c\n\x05\x06\0\x02\x07\x03\
    \x12\x037&5\n\r\n\x05\x06\0\x02\x07\x04\x12\x048\x04;\x06\n\x11\n\t\x06\
    \0\x02\x07\x04\xb0\xca\xbc\"\x12\x048\x04;\x06\n\x0c\n\x04\x06\0\x02\x08\
    \x12\x04>\x02B\x03\n\x0c\n\x05\x06\0\x02\x08\x01\x12\x03>\x06\x16\n\x0c\
    \n\x05\x06\0\x02\x08\x02\x12\x03>\x18,\n\x0c\n\x05\x06\0\x02\x08\x03\x12\
    \x03>7O\n\r\n\x05\x06\0\x02\x08\x04\x12\x04?\x04A\x06\n\x11\n\t\x06\0\
    \x02\x08\x04\xb0\xca\xbc\"\x12\x04?\x04A\x06\n-\n\x04\x06\0\x02\t\x12\
    \x04E\x02I\x03\x1a\x1f\x20all\x20port\x20values\x20for\x20an\x20object\n\
    \n\x0c\n\x05\x06\0\x02\t\x01\x12\x03E\x06\x15\n\x0c\n\x05\x06\0\x02\t\
    \x02\x12\x03E\x17*\n\x0c\n\x05\x06\0\x02\t\x03\x12\x03E5L\n\r\n\x05\x06\
    \0\x02\t\x04\x12\x04F\x04H\x06\n\x11\n\t\x06\0\x02\t\x04\xb0\xca\xbc\"\
    \x12\x04F\x04H\x06\n/\n\x04\x06\0\x02\n\x12\x04L\x02P\x03\x1a!\x20single\
    \x20port\x20value\x20for\x20an\x20object\n\n\x0c\n\x05\x06\0\x02\n\x01\
    \x12\x03L\x06\x12\n\x0c\n\x05\x06\0\x02\n\x02\x12\x03L\x14\x1f\n\x0c\n\
    \x05\x06\0\x02\n\x03\x12\x03L*3\n\r\n\x05\x06\0\x02\n\x04\x12\x04M\x04O\
    \x06\n\x11\n\t\x06\0\x02\n\x04\xb0\xca\xbc\"\x12\x04M\x04O\x06\n\x0c\n\
    \x04\x06\0\x02\x0b\x12\x04S\x02X\x03\n\x0c\n\x05\x06\0\x02\x0b\x01\x12\
    \x03S\x06\x14\n\x0c\n\x05\x06\0\x02\x0b\x02\x12\x03S\x16\x20\n\x0c\n\x05\
    \x06\0\x02\x0b\x03\x12\x03S+9\n\r\n\x05\x06\0\x02\x0b\x04\x12\x04T\x04W\
    \x06\n\x11\n\t\x06\0\x02\x0b\x04\xb0\xca\xbc\"\x12\x04T\x04W\x06\n\x0c\n\
    \x04\x06\0\x02\x0c\x12\x04Z\x02_\x03\n\x0c\n\x05\x06\0\x02\x0c\x01\x12\
    \x03Z\x06\x16\n\x0c\n\x05\x06\0\x02\x0c\x02\x12\x03Z\x18\"\n\x0c\n\x05\
    \x06\0\x02\x0c\x03\x12\x03Z-;\n\r\n\x05\x06\0\x02\x0c\x04\x12\x04[\x04^\
    \x06\n\x11\n\t\x06\0\x02\x0c\x04\xb0\xca\xbc\"\x12\x04[\x04^\x06\n\x0c\n\
    \x04\x06\0\x02\r\x12\x04a\x02e\x03\n\x0c\n\x05\x06\0\x02\r\x01\x12\x03a\
    \x06\x11\n\x0c\n\x05\x06\0\x02\r\x02\x12\x03a\x13\x18\n\x0c\n\x05\x06\0\
    \x02\r\x03\x12\x03a#-\n\r\n\x05\x06\0\x02\r\x04\x12\x04b\x04d\x06\n\x11\
    \n\t\x06\0\x02\r\x04\xb0\xca\xbc\"\x12\x04b\x04d\x06\n\x0c\n\x04\x06\0\
    \x02\x0e\x12\x04g\x02l\x03\n\x0c\n\x05\x06\0\x02\x0e\x01\x12\x03g\x06\
    \x10\n\x0c\n\x05\x06\0\x02\x0e\x02\x12\x03g\x12\x1c\n\x0c\n\x05\x06\0\
    \x02\x0e\x03\x12\x03g'5\n\r\n\x05\x06\0\x02\x0e\x04\x12\x04h\x04k\x06\n\
    \x11\n\t\x06\0\x02\x0e\x04\xb0\xca\xbc\"\x12\x04h\x04k\x06\n\x0c\n\x04\
    \x06\0\x02\x0f\x12\x04n\x02r\x03\n\x0c\n\x05\x06\0\x02\x0f\x01\x12\x03n\
    \x06\x10\n\x0c\n\x05\x06\0\x02\x0f\x02\x12\x03n\x12\x17\n\x0c\n\x05\x06\
    \0\x02\x0f\x03\x12\x03n\",\n\r\n\x05\x06\0\x02\x0f\x04\x12\x04o\x04q\x06\
    \n\x11\n\t\x06\0\x02\x0f\x04\xb0\xca\xbc\"\x12\x04o\x04q\x06\n\x0b\n\x04\
    \x06\0\x02\x10\x12\x03w\x02R\n\x0c\n\x05\x06\0\x02\x10\x01\x12\x03w\x06\
    \x1a\n\x0c\n\x05\x06\0\x02\x10\x05\x12\x03w\x1b!\n\x0c\n\x05\x06\0\x02\
    \x10\x02\x12\x03w\"0\n\x0c\n\x05\x06\0\x02\x10\x06\x12\x03w;A\n\x0c\n\
    \x05\x06\0\x02\x10\x03\x12\x03wBP\n\x0b\n\x02\x04\0\x12\x05{\0\x82\x01\
    \x01\n\n\n\x03\x04\0\x01\x12\x03{\x08\x16\n\x0b\n\x04\x04\0\x02\0\x12\
    \x03|\x02\x12\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03|\x02\x08\n\x0c\n\x05\
    \x04\0\x02\0\x01\x12\x03|\t\r\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03|\x10\
    \x11\n\x0b\n\x04\x04\0\x02\x01\x12\x03}\x02\x11\n\x0c\n\x05\x04\0\x02\
    \x01\x05\x12\x03}\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03}\t\x0c\n\
    \x0c\n\x05\x04\0\x02\x01\x03\x12\x03}\x0f\x10\n\x0b\n\x04\x04\0\x02\x02\
    \x12\x03~\x02\x1a\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03~\x02\x0e\n\x0c\n\
    \x05\x04\0\x02\x02\x01\x12\x03~\x0f\x15\n\x0c\n\x05\x04\0\x02\x02\x03\
    \x12\x03~\x18\x19\n\x0b\n\x04\x04\0\x02\x03\x12\x03\x7f\x02#\n\x0c\n\x05\
    \x04\0\x02\x03\x04\x12\x03\x7f\x02\n\n\x0c\n\x05\x04\0\x02\x03\x06\x12\
    \x03\x7f\x0b\x17\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x7f\x18\x1e\n\x0c\
    \n\x05\x04\0\x02\x03\x03\x12\x03\x7f!\"\n\x0c\n\x04\x04\0\x02\x04\x12\
    \x04\x80\x01\x02\x11\n\r\n\x05\x04\0\x02\x04\x05\x12\x04\x80\x01\x02\x07\
    \n\r\n\x05\x04\0\x02\x04\x01\x12\x04\x80\x01\x08\x0c\n\r\n\x05\x04\0\x02\
    \x04\x03\x12\x04\x80\x01\x0f\x10\n\x0c\n\x04\x04\0\x02\x05\x12\x04\x81\
    \x01\x02\x16\n\r\n\x05\x04\0\x02\x05\x06\x12\x04\x81\x01\x02\t\n\r\n\x05\
    \x04\0\x02\x05\x01\x12\x04\x81\x01\n\x11\n\r\n\x05\x04\0\x02\x05\x03\x12\
    \x04\x81\x01\x14\x15\n\x0c\n\x02\x04\x01\x12\x06\x85\x01\0\x89\x01\x01\n\
    \x0b\n\x03\x04\x01\x01\x12\x04\x85\x01\x08\x12\n\x0c\n\x04\x04\x01\x02\0\
    \x12\x04\x86\x01\x02\x12\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\x86\x01\x02\
    \x08\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\x86\x01\t\r\n\r\n\x05\x04\x01\
    \x02\0\x03\x12\x04\x86\x01\x10\x11\n\x0c\n\x04\x04\x01\x02\x01\x12\x04\
    \x87\x01\x02\x12\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\x87\x01\x02\x08\n\
    \r\n\x05\x04\x01\x02\x01\x01\x12\x04\x87\x01\t\r\n\r\n\x05\x04\x01\x02\
    \x01\x03\x12\x04\x87\x01\x10\x11\n\x0c\n\x04\x04\x01\x02\x02\x12\x04\x88\
    \x01\x02#\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04\x88\x01\x02\n\n\r\n\x05\
    \x04\x01\x02\x02\x06\x12\x04\x88\x01\x0b\x17\n\r\n\x05\x04\x01\x02\x02\
    \x01\x12\x04\x88\x01\x18\x1e\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\x88\
    \x01!\"\n\x0c\n\x02\x04\x02\x12\x06\x8b\x01\0\x8d\x01\x01\n\x0b\n\x03\
    \x04\x02\x01\x12\x04\x8b\x01\x08\x16\n\x0c\n\x04\x04\x02\x02\0\x12\x04\
    \x8c\x01\x02\x15\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\x8c\x01\x02\x08\n\r\
    \n\x05\x04\x02\x02\0\x01\x12\x04\x8c\x01\t\x10\n\r\n\x05\x04\x02\x02\0\
    \x03\x12\x04\x8c\x01\x13\x14\n\x0c\n\x02\x04\x03\x12\x06\x8f\x01\0\x91\
    \x01\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\x8f\x01\x08\x12\n\x0c\n\x04\x04\
    \x03\x02\0\x12\x04\x90\x01\x02\"\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\x90\
    \x01\x02\n\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\x90\x01\x0b\x15\n\r\n\x05\
    \x04\x03\x02\0\x01\x12\x04\x90\x01\x16\x1d\n\r\n\x05\x04\x03\x02\0\x03\
    \x12\x04\x90\x01\x20!\n\x0c\n\x02\x04\x04\x12\x06\x94\x01\0\x96\x01\x01\
    \n\x0b\n\x03\x04\x04\x01\x12\x04\x94\x01\x08\x20\n\x0c\n\x04\x04\x04\x02\
    \0\x12\x04\x95\x01\x022\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\x95\x01\x02&\
    \n\r\n\x05\x04\x04\x02\0\x01\x12\x04\x95\x01'-\n\r\n\x05\x04\x04\x02\0\
    \x03\x12\x04\x95\x0101\n\x0c\n\x02\x04\x05\x12\x06\x99\x01\0\x9b\x01\x01\
    \n\x0b\n\x03\x04\x05\x01\x12\x04\x99\x01\x08\x1f\n\x0c\n\x04\x04\x05\x02\
    \0\x12\x04\x9a\x01\x02!\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\x9a\x01\x02\
    \n\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\x9a\x01\x0c\x15\n\r\n\x05\x04\x05\
    \x02\0\x01\x12\x04\x9a\x01\x16\x1c\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\
    \x9a\x01\x1f\x20\n\x0c\n\x02\x04\x06\x12\x06\x9d\x01\0\x9f\x01\x01\n\x0b\
    \n\x03\x04\x06\x01\x12\x04\x9d\x01\x08\x1c\n\x0c\n\x04\x04\x06\x02\0\x12\
    \x04\x9e\x01\x02\x13\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\x9e\x01\x02\x06\
    \n\r\n\x05\x04\x06\x02\0\x01\x12\x04\x9e\x01\x07\x0e\n\r\n\x05\x04\x06\
    \x02\0\x03\x12\x04\x9e\x01\x11\x12\n\x0c\n\x02\x04\x07\x12\x06\xa1\x01\0\
    \xa4\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xa1\x01\x08\x1b\n\x0c\n\x04\
    \x04\x07\x02\0\x12\x04\xa2\x01\x02\x12\n\r\n\x05\x04\x07\x02\0\x05\x12\
    \x04\xa2\x01\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xa2\x01\t\r\n\r\
    \n\x05\x04\x07\x02\0\x03\x12\x04\xa2\x01\x10\x11\n\x0c\n\x04\x04\x07\x02\
    \x01\x12\x04\xa3\x01\x02\x13\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xa3\
    \x01\x02\x06\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xa3\x01\x07\x0e\n\r\n\
    \x05\x04\x07\x02\x01\x03\x12\x04\xa3\x01\x11\x12\n\x0c\n\x02\x04\x08\x12\
    \x06\xa6\x01\0\xa9\x01\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\xa6\x01\x08\
    \x13\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xa7\x01\x02\x18\n\r\n\x05\x04\x08\
    \x02\0\x05\x12\x04\xa7\x01\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\
    \xa7\x01\t\x13\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xa7\x01\x16\x17\n\x0c\
    \n\x04\x04\x08\x02\x01\x12\x04\xa8\x01\x02\x14\n\r\n\x05\x04\x08\x02\x01\
    \x05\x12\x04\xa8\x01\x02\x08\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xa8\
    \x01\t\x0f\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xa8\x01\x12\x13\n\x0c\n\
    \x02\x04\t\x12\x06\xab\x01\0\xb4\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\
    \xab\x01\x08\x11\n\x0c\n\x04\x04\t\x02\0\x12\x04\xac\x01\x02\x14\n\r\n\
    \x05\x04\t\x02\0\x05\x12\x04\xac\x01\x02\x08\n\r\n\x05\x04\t\x02\0\x01\
    \x12\x04\xac\x01\t\x0f\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xac\x01\x12\x13\
    \n\x0c\n\x04\x04\t\x02\x01\x12\x04\xad\x01\x02\x16\n\r\n\x05\x04\t\x02\
    \x01\x05\x12\x04\xad\x01\x02\x08\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xad\
    \x01\t\x11\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xad\x01\x14\x15\n\x0c\n\
    \x04\x04\t\x02\x02\x12\x04\xae\x01\x02\x11\n\r\n\x05\x04\t\x02\x02\x05\
    \x12\x04\xae\x01\x02\x06\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xae\x01\x07\
    \x0c\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xae\x01\x0f\x10\n\x0c\n\x04\x04\
    \t\x02\x03\x12\x04\xaf\x01\x02!\n\r\n\x05\x04\t\x02\x03\x05\x12\x04\xaf\
    \x01\x02\x06\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xaf\x01\x07\x1c\n\r\n\
    \x05\x04\t\x02\x03\x03\x12\x04\xaf\x01\x1f\x20\n\x0c\n\x04\x04\t\x02\x04\
    \x12\x04\xb0\x01\x02\x11\n\r\n\x05\x04\t\x02\x04\x05\x12\x04\xb0\x01\x02\
    \x07\n\r\n\x05\x04\t\x02\x04\x01\x12\x04\xb0\x01\x08\x0c\n\r\n\x05\x04\t\
    \x02\x04\x03\x12\x04\xb0\x01\x0f\x10\n\x0c\n\x04\x04\t\x02\x05\x12\x04\
    \xb1\x01\x02\x14\n\r\n\x05\x04\t\x02\x05\x05\x12\x04\xb1\x01\x02\x08\n\r\
    \n\x05\x04\t\x02\x05\x01\x12\x04\xb1\x01\t\x0f\n\r\n\x05\x04\t\x02\x05\
    \x03\x12\x04\xb1\x01\x12\x13\n\x0c\n\x04\x04\t\x02\x06\x12\x04\xb2\x01\
    \x02)\n\r\n\x05\x04\t\x02\x06\x06\x12\x04\xb2\x01\x02\x15\n\r\n\x05\x04\
    \t\x02\x06\x01\x12\x04\xb2\x01\x16$\n\r\n\x05\x04\t\x02\x06\x03\x12\x04\
    \xb2\x01'(\n\x0c\n\x04\x04\t\x02\x07\x12\x04\xb3\x01\x02\x1e\n\r\n\x05\
    \x04\t\x02\x07\x04\x12\x04\xb3\x01\x02\n\n\r\n\x05\x04\t\x02\x07\x05\x12\
    \x04\xb3\x01\x0b\x11\n\r\n\x05\x04\t\x02\x07\x01\x12\x04\xb3\x01\x12\x19\
    \n\r\n\x05\x04\t\x02\x07\x03\x12\x04\xb3\x01\x1c\x1d\n\x0c\n\x02\x04\n\
    \x12\x06\xb6\x01\0\xb9\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\xb6\x01\x08\
    \x1b\n\x0c\n\x04\x04\n\x02\0\x12\x04\xb7\x01\x02\x12\n\r\n\x05\x04\n\x02\
    \0\x05\x12\x04\xb7\x01\x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xb7\x01\
    \t\r\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xb7\x01\x10\x11\n\x0c\n\x04\x04\n\
    \x02\x01\x12\x04\xb8\x01\x02\x14\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xb8\
    \x01\x02\x07\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xb8\x01\x08\x0f\n\r\n\
    \x05\x04\n\x02\x01\x03\x12\x04\xb8\x01\x12\x13\n\x0c\n\x02\x04\x0b\x12\
    \x06\xbd\x01\0\xbf\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xbd\x01\x08\
    \x16\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xbe\x01\x02\x14\n\r\n\x05\x04\x0b\
    \x02\0\x05\x12\x04\xbe\x01\x02\x06\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\
    \xbe\x01\x07\x0f\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xbe\x01\x12\x13\n\
    \x0c\n\x02\x04\x0c\x12\x06\xc1\x01\0\xc2\x01\x01\n\x0b\n\x03\x04\x0c\x01\
    \x12\x04\xc1\x01\x08\x15\n\x0c\n\x02\x04\r\x12\x06\xc5\x01\0\xc7\x01\x01\
    \n\x0b\n\x03\x04\r\x01\x12\x04\xc5\x01\x08\x12\n\x0c\n\x04\x04\r\x02\0\
    \x12\x04\xc6\x01\x02\"\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xc6\x01\x02\x15\
    \n\r\n\x05\x04\r\x02\0\x01\x12\x04\xc6\x01\x16\x1d\n\r\n\x05\x04\r\x02\0\
    \x03\x12\x04\xc6\x01\x20!\n\x0c\n\x02\x04\x0e\x12\x06\xc9\x01\0\xcd\x01\
    \x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xc9\x01\x08\x0e\n\x0c\n\x04\x04\x0e\
    \x02\0\x12\x04\xca\x01\x021\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xca\x01\
    \x02$\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xca\x01%,\n\r\n\x05\x04\x0e\
    \x02\0\x03\x12\x04\xca\x01/0\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xcb\x01\
    \x02/\n\r\n\x05\x04\x0e\x02\x01\x06\x12\x04\xcb\x01\x02$\n\r\n\x05\x04\
    \x0e\x02\x01\x01\x12\x04\xcb\x01%*\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\
    \xcb\x01-.\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\xcc\x01\x022\n\r\n\x05\
    \x04\x0e\x02\x02\x06\x12\x04\xcc\x01\x02$\n\r\n\x05\x04\x0e\x02\x02\x01\
    \x12\x04\xcc\x01%-\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xcc\x0101\n\x0c\
    \n\x02\x04\x0f\x12\x06\xcf\x01\0\xd1\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\
    \x04\xcf\x01\x08\x1d\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xd0\x01\x02(\n\r\
    \n\x05\x04\x0f\x02\0\x06\x12\x04\xd0\x01\x02\x1b\n\r\n\x05\x04\x0f\x02\0\
    \x01\x12\x04\xd0\x01\x1c#\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xd0\x01&'\
    \n\x0c\n\x02\x04\x10\x12\x06\xd3\x01\0\xe0\x01\x01\n\x0b\n\x03\x04\x10\
    \x01\x12\x04\xd3\x01\x08\x0f\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xd4\x01\
    \x02\x1c\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xd4\x01\x02\x08\n\r\n\x05\
    \x04\x10\x02\0\x01\x12\x04\xd4\x01\t\x17\n\r\n\x05\x04\x10\x02\0\x03\x12\
    \x04\xd4\x01\x1a\x1b\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xd5\x01\x02\x1c\
    \n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xd5\x01\x02\x08\n\r\n\x05\x04\x10\
    \x02\x01\x01\x12\x04\xd5\x01\t\x17\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\
    \xd5\x01\x1a\x1b\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\xd6\x01\x02\x1e\n\r\
    \n\x05\x04\x10\x02\x02\x05\x12\x04\xd6\x01\x02\x08\n\r\n\x05\x04\x10\x02\
    \x02\x01\x12\x04\xd6\x01\t\x19\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xd6\
    \x01\x1c\x1d\n\x0c\n\x04\x04\x10\x02\x03\x12\x04\xd7\x01\x02\x1e\n\r\n\
    \x05\x04\x10\x02\x03\x05\x12\x04\xd7\x01\x02\x08\n\r\n\x05\x04\x10\x02\
    \x03\x01\x12\x04\xd7\x01\t\x19\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\xd7\
    \x01\x1c\x1d\n\x0c\n\x04\x04\x10\x02\x04\x12\x04\xd8\x01\x02\x1d\n\r\n\
    \x05\x04\x10\x02\x04\x05\x12\x04\xd8\x01\x02\x08\n\r\n\x05\x04\x10\x02\
    \x04\x01\x12\x04\xd8\x01\t\x18\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\xd8\
    \x01\x1b\x1c\n\x0c\n\x04\x04\x10\x02\x05\x12\x04\xd9\x01\x02\x11\n\r\n\
    \x05\x04\x10\x02\x05\x05\x12\x04\xd9\x01\x02\x08\n\r\n\x05\x04\x10\x02\
    \x05\x01\x12\x04\xd9\x01\t\x0c\n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\xd9\
    \x01\x0f\x10\n\x0c\n\x04\x04\x10\x02\x06\x12\x04\xda\x01\x02\x13\n\r\n\
    \x05\x04\x10\x02\x06\x05\x12\x04\xda\x01\x02\x08\n\r\n\x05\x04\x10\x02\
    \x06\x01\x12\x04\xda\x01\t\x0e\n\r\n\x05\x04\x10\x02\x06\x03\x12\x04\xda\
    \x01\x11\x12\n\x0c\n\x04\x04\x10\x02\x07\x12\x04\xdb\x01\x02\x1b\n\r\n\
    \x05\x04\x10\x02\x07\x04\x12\x04\xdb\x01\x02\n\n\r\n\x05\x04\x10\x02\x07\
    \x05\x12\x04\xdb\x01\x0b\x11\n\r\n\x05\x04\x10\x02\x07\x01\x12\x04\xdb\
    \x01\x12\x16\n\r\n\x05\x04\x10\x02\x07\x03\x12\x04\xdb\x01\x19\x1a\n\x0c\
    \n\x04\x04\x10\x02\x08\x12\x04\xdc\x01\x02\x1f\n\r\n\x05\x04\x10\x02\x08\
    \x06\x12\x04\xdc\x01\x02\x15\n\r\n\x05\x04\x10\x02\x08\x01\x12\x04\xdc\
    \x01\x16\x1a\n\r\n\x05\x04\x10\x02\x08\x03\x12\x04\xdc\x01\x1d\x1e\n\x0c\
    \n\x04\x04\x10\x02\t\x12\x04\xdd\x01\x02\x12\n\r\n\x05\x04\x10\x02\t\x05\
    \x12\x04\xdd\x01\x02\x07\n\r\n\x05\x04\x10\x02\t\x01\x12\x04\xdd\x01\x08\
    \x0c\n\r\n\x05\x04\x10\x02\t\x03\x12\x04\xdd\x01\x0f\x11\n\x0c\n\x04\x04\
    \x10\x02\n\x12\x04\xde\x01\x02\x1b\n\r\n\x05\x04\x10\x02\n\x06\x12\x04\
    \xde\x01\x02\x0e\n\r\n\x05\x04\x10\x02\n\x01\x12\x04\xde\x01\x0f\x15\n\r\
    \n\x05\x04\x10\x02\n\x03\x12\x04\xde\x01\x18\x1a\n\x0c\n\x04\x04\x10\x02\
    \x0b\x12\x04\xdf\x01\x02%\n\r\n\x05\x04\x10\x02\x0b\x04\x12\x04\xdf\x01\
    \x02\n\n\r\n\x05\x04\x10\x02\x0b\x06\x12\x04\xdf\x01\x0b\x14\n\r\n\x05\
    \x04\x10\x02\x0b\x01\x12\x04\xdf\x01\x15\x1f\n\r\n\x05\x04\x10\x02\x0b\
    \x03\x12\x04\xdf\x01\"$\n\x0c\n\x02\x04\x11\x12\x06\xe3\x01\0\xee\x01\
    \x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xe3\x01\x08\x17\n\x0c\n\x04\x04\x11\
    \x02\0\x12\x04\xe4\x01\x02\x16\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xe4\
    \x01\x02\x08\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xe4\x01\t\x11\n\r\n\x05\
    \x04\x11\x02\0\x03\x12\x04\xe4\x01\x14\x15\n\x0c\n\x04\x04\x11\x02\x01\
    \x12\x04\xe5\x01\x02\x12\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xe5\x01\
    \x02\x07\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xe5\x01\x08\r\n\r\n\x05\
    \x04\x11\x02\x01\x03\x12\x04\xe5\x01\x10\x11\n\x0c\n\x04\x04\x11\x02\x02\
    \x12\x04\xe6\x01\x02%\n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\xe6\x01\x02\
    \x15\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xe6\x01\x16\x20\n\r\n\x05\x04\
    \x11\x02\x02\x03\x12\x04\xe6\x01#$\n\x0c\n\x04\x04\x11\x02\x03\x12\x04\
    \xe7\x01\x02\x14\n\r\n\x05\x04\x11\x02\x03\x05\x12\x04\xe7\x01\x02\x08\n\
    \r\n\x05\x04\x11\x02\x03\x01\x12\x04\xe7\x01\t\x0f\n\r\n\x05\x04\x11\x02\
    \x03\x03\x12\x04\xe7\x01\x12\x13\n\x0c\n\x04\x04\x11\x02\x04\x12\x04\xe8\
    \x01\x02\x13\n\r\n\x05\x04\x11\x02\x04\x05\x12\x04\xe8\x01\x02\x06\n\r\n\
    \x05\x04\x11\x02\x04\x01\x12\x04\xe8\x01\x07\x0e\n\r\n\x05\x04\x11\x02\
    \x04\x03\x12\x04\xe8\x01\x11\x12\n\x0c\n\x04\x04\x11\x02\x05\x12\x04\xe9\
    \x01\x02\x13\n\r\n\x05\x04\x11\x02\x05\x05\x12\x04\xe9\x01\x02\x08\n\r\n\
    \x05\x04\x11\x02\x05\x01\x12\x04\xe9\x01\t\x0e\n\r\n\x05\x04\x11\x02\x05\
    \x03\x12\x04\xe9\x01\x11\x12\n\x0c\n\x04\x04\x11\x02\x06\x12\x04\xea\x01\
    \x02\x18\n\r\n\x05\x04\x11\x02\x06\x05\x12\x04\xea\x01\x02\x08\n\r\n\x05\
    \x04\x11\x02\x06\x01\x12\x04\xea\x01\t\x13\n\r\n\x05\x04\x11\x02\x06\x03\
    \x12\x04\xea\x01\x16\x17\n\x0c\n\x04\x04\x11\x02\x07\x12\x04\xeb\x01\x02\
    \x10\n\r\n\x05\x04\x11\x02\x07\x05\x12\x04\xeb\x01\x02\x07\n\r\n\x05\x04\
    \x11\x02\x07\x01\x12\x04\xeb\x01\x08\x0b\n\r\n\x05\x04\x11\x02\x07\x03\
    \x12\x04\xeb\x01\x0e\x0f\n\x0c\n\x04\x04\x11\x02\x08\x12\x04\xec\x01\x02\
    (\n\r\n\x05\x04\x11\x02\x08\x04\x12\x04\xec\x01\x02\n\n\r\n\x05\x04\x11\
    \x02\x08\x06\x12\x04\xec\x01\x0b\x1a\n\r\n\x05\x04\x11\x02\x08\x01\x12\
    \x04\xec\x01\x1b#\n\r\n\x05\x04\x11\x02\x08\x03\x12\x04\xec\x01&'\n\x0c\
    \n\x04\x04\x11\x02\t\x12\x04\xed\x01\x02.\n\r\n\x05\x04\x11\x02\t\x04\
    \x12\x04\xed\x01\x02\n\n\r\n\x05\x04\x11\x02\t\x06\x12\x04\xed\x01\x0b\
    \x17\n\r\n\x05\x04\x11\x02\t\x01\x12\x04\xed\x01\x18(\n\r\n\x05\x04\x11\
    \x02\t\x03\x12\x04\xed\x01+-\n0\n\x02\x04\x12\x12\x06\xf4\x01\0\xf5\x01\
    \x01\x1a\"\x20New\x20message\x20for\x20the\x20Ping\x20request\n\n\x0b\n\
    \x03\x04\x12\x01\x12\x04\xf4\x01\x08\x13\n1\n\x02\x04\x13\x12\x06\xf9\
    \x01\0\xfb\x01\x01\x1a#\x20New\x20message\x20for\x20the\x20Ping\x20respo\
    nse\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xf9\x01\x08\x14\n\x0c\n\x04\x04\
    \x13\x02\0\x12\x04\xfa\x01\x02\x15\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\
    \xfa\x01\x02\x08\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xfa\x01\t\x10\n\r\n\
    \x05\x04\x13\x02\0\x03\x12\x04\xfa\x01\x13\x14\n\x0c\n\x02\x04\x14\x12\
    \x06\xfe\x01\0\x82\x02\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xfe\x01\x08\
    \x14\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xff\x01\x02\x1e\n\r\n\x05\x04\x14\
    \x02\0\x04\x12\x04\xff\x01\x02\n\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xff\
    \x01\x0b\x11\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xff\x01\x12\x19\n\r\n\
    \x05\x04\x14\x02\0\x03\x12\x04\xff\x01\x1c\x1d\n\x0c\n\x04\x04\x14\x02\
    \x01\x12\x04\x80\x02\x02\x20\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\x80\
    \x02\x02\n\n\r\n\x05\x04\x14\x02\x01\x06\x12\x04\x80\x02\x0b\x17\n\r\n\
    \x05\x04\x14\x02\x01\x01\x12\x04\x80\x02\x18\x1b\n\r\n\x05\x04\x14\x02\
    \x01\x03\x12\x04\x80\x02\x1e\x1f\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\x81\
    \x02\x02$\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\x81\x02\x02\n\n\r\n\x05\
    \x04\x14\x02\x02\x06\x12\x04\x81\x02\x0b\x17\n\r\n\x05\x04\x14\x02\x02\
    \x01\x12\x04\x81\x02\x18\x1f\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\x81\
    \x02\"#\n\n\n\x02\x04\x15\x12\x04\x85\x02\0\x10\n\x0b\n\x03\x04\x15\x01\
    \x12\x04\x85\x02\x08\r\n\x0c\n\x02\x04\x16\x12\x06\x87\x02\0\x89\x02\x01\
    \n\x0b\n\x03\x04\x16\x01\x12\x04\x87\x02\x08\x17\n\x0c\n\x04\x04\x16\x02\
    \0\x12\x04\x88\x02\x02$\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\x88\x02\x02\
    \n\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\x88\x02\x0b\x17\n\r\n\x05\x04\x16\
    \x02\0\x01\x12\x04\x88\x02\x18\x1f\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\
    \x88\x02\"#\n\x0c\n\x02\x04\x17\x12\x06\x8b\x02\0\x8e\x02\x01\n\x0b\n\
    \x03\x04\x17\x01\x12\x04\x8b\x02\x08\x15\n\x0c\n\x04\x04\x17\x02\0\x12\
    \x04\x8c\x02\x02\x12\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\x8c\x02\x02\x08\
    \n\r\n\x05\x04\x17\x02\0\x01\x12\x04\x8c\x02\t\r\n\r\n\x05\x04\x17\x02\0\
    \x03\x12\x04\x8c\x02\x10\x11\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\x8d\x02\
    \x02\x16\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\x8d\x02\x02\x06\n\r\n\x05\
    \x04\x17\x02\x01\x01\x12\x04\x8d\x02\x07\x11\n\r\n\x05\x04\x17\x02\x01\
    \x03\x12\x04\x8d\x02\x14\x15\n\x0c\n\x02\x04\x18\x12\x06\x92\x02\0\x9b\
    \x02\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\x92\x02\x08\x14\n\x0c\n\x04\x04\
    \x18\x02\0\x12\x04\x93\x02\x02\x10\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\
    \x93\x02\x02\x08\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\x93\x02\t\x0b\n\r\n\
    \x05\x04\x18\x02\0\x03\x12\x04\x93\x02\x0e\x0f\n\x0c\n\x04\x04\x18\x02\
    \x01\x12\x04\x94\x02\x02\x10\n\r\n\x05\x04\x18\x02\x01\x06\x12\x04\x94\
    \x02\x02\x06\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\x94\x02\x07\x0b\n\r\n\
    \x05\x04\x18\x02\x01\x03\x12\x04\x94\x02\x0e\x0f\n\x0c\n\x04\x04\x18\x02\
    \x02\x12\x04\x95\x02\x02\x1b\n\r\n\x05\x04\x18\x02\x02\x04\x12\x04\x95\
    \x02\x02\n\n\r\n\x05\x04\x18\x02\x02\x06\x12\x04\x95\x02\x0b\x0f\n\r\n\
    \x05\x04\x18\x02\x02\x01\x12\x04\x95\x02\x10\x16\n\r\n\x05\x04\x18\x02\
    \x02\x03\x12\x04\x95\x02\x19\x1a\n\x0c\n\x04\x04\x18\x02\x03\x12\x04\x96\
    \x02\x02\x1c\n\r\n\x05\x04\x18\x02\x03\x04\x12\x04\x96\x02\x02\n\n\r\n\
    \x05\x04\x18\x02\x03\x06\x12\x04\x96\x02\x0b\x0f\n\r\n\x05\x04\x18\x02\
    \x03\x01\x12\x04\x96\x02\x10\x17\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\
    \x96\x02\x1a\x1b\n\x0c\n\x04\x04\x18\x02\x04\x12\x04\x97\x02\x02\x10\n\r\
    \n\x05\x04\x18\x02\x04\x06\x12\x04\x97\x02\x02\x06\n\r\n\x05\x04\x18\x02\
    \x04\x01\x12\x04\x97\x02\x07\x0b\n\r\n\x05\x04\x18\x02\x04\x03\x12\x04\
    \x97\x02\x0e\x0f\n\x0c\n\x04\x04\x18\x02\x05\x12\x04\x98\x02\x02\x18\n\r\
    \n\x05\x04\x18\x02\x05\x06\x12\x04\x98\x02\x02\r\n\r\n\x05\x04\x18\x02\
    \x05\x01\x12\x04\x98\x02\x0e\x13\n\r\n\x05\x04\x18\x02\x05\x03\x12\x04\
    \x98\x02\x16\x17\n\x0c\n\x04\x04\x18\x02\x06\x12\x04\x99\x02\x02&\n\r\n\
    \x05\x04\x18\x02\x06\x04\x12\x04\x99\x02\x02\n\n\r\n\x05\x04\x18\x02\x06\
    \x06\x12\x04\x99\x02\x0b\x15\n\r\n\x05\x04\x18\x02\x06\x01\x12\x04\x99\
    \x02\x16!\n\r\n\x05\x04\x18\x02\x06\x03\x12\x04\x99\x02$%\n\x0c\n\x04\
    \x04\x18\x02\x07\x12\x04\x9a\x02\x02\x18\n\r\n\x05\x04\x18\x02\x07\x06\
    \x12\x04\x9a\x02\x02\n\n\r\n\x05\x04\x18\x02\x07\x01\x12\x04\x9a\x02\x0b\
    \x13\n\r\n\x05\x04\x18\x02\x07\x03\x12\x04\x9a\x02\x16\x17\n\x0c\n\x02\
    \x04\x19\x12\x06\x9d\x02\0\x9f\x02\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\
    \x9d\x02\x08\x10\n\x0c\n\x04\x04\x19\x02\0\x12\x04\x9e\x02\x02\x12\n\r\n\
    \x05\x04\x19\x02\0\x05\x12\x04\x9e\x02\x02\x07\n\r\n\x05\x04\x19\x02\0\
    \x01\x12\x04\x9e\x02\x08\r\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\x9e\x02\
    \x10\x11\n\x0c\n\x02\x04\x1a\x12\x06\xa1\x02\0\xae\x02\x01\n\x0b\n\x03\
    \x04\x1a\x01\x12\x04\xa1\x02\x08\x0c\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\
    \xa2\x02\x02\x16\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xa2\x02\x02\x08\n\r\
    \n\x05\x04\x1a\x02\0\x01\x12\x04\xa2\x02\t\x11\n\r\n\x05\x04\x1a\x02\0\
    \x03\x12\x04\xa2\x02\x14\x15\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xa3\x02\
    \x02\x18\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\xa3\x02\x02\x08\n\r\n\x05\
    \x04\x1a\x02\x01\x01\x12\x04\xa3\x02\t\x13\n\r\n\x05\x04\x1a\x02\x01\x03\
    \x12\x04\xa3\x02\x16\x17\n\x0c\n\x04\x04\x1a\x02\x02\x12\x04\xa4\x02\x02\
    \x16\n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\xa4\x02\x02\x08\n\r\n\x05\x04\
    \x1a\x02\x02\x01\x12\x04\xa4\x02\t\x11\n\r\n\x05\x04\x1a\x02\x02\x03\x12\
    \x04\xa4\x02\x14\x15\n\x0c\n\x04\x04\x1a\x02\x03\x12\x04\xa5\x02\x02\x18\
    \n\r\n\x05\x04\x1a\x02\x03\x05\x12\x04\xa5\x02\x02\x08\n\r\n\x05\x04\x1a\
    \x02\x03\x01\x12\x04\xa5\x02\t\x13\n\r\n\x05\x04\x1a\x02\x03\x03\x12\x04\
    \xa5\x02\x16\x17\n\x0c\n\x04\x04\x1a\x02\x04\x12\x04\xa6\x02\x02\x1a\n\r\
    \n\x05\x04\x1a\x02\x04\x05\x12\x04\xa6\x02\x02\x08\n\r\n\x05\x04\x1a\x02\
    \x04\x01\x12\x04\xa6\x02\t\x15\n\r\n\x05\x04\x1a\x02\x04\x03\x12\x04\xa6\
    \x02\x18\x19\n\x0c\n\x04\x04\x1a\x02\x05\x12\x04\xa7\x02\x02\x20\n\r\n\
    \x05\x04\x1a\x02\x05\x05\x12\x04\xa7\x02\x02\x08\n\r\n\x05\x04\x1a\x02\
    \x05\x01\x12\x04\xa7\x02\t\x1b\n\r\n\x05\x04\x1a\x02\x05\x03\x12\x04\xa7\
    \x02\x1e\x1f\n\x0c\n\x04\x04\x1a\x02\x06\x12\x04\xa8\x02\x02\x20\n\r\n\
    \x05\x04\x1a\x02\x06\x05\x12\x04\xa8\x02\x02\x08\n\r\n\x05\x04\x1a\x02\
    \x06\x01\x12\x04\xa8\x02\t\x1b\n\r\n\x05\x04\x1a\x02\x06\x03\x12\x04\xa8\
    \x02\x1e\x1f\n\x0c\n\x04\x04\x1a\x02\x07\x12\x04\xa9\x02\x02*\n\r\n\x05\
    \x04\x1a\x02\x07\x04\x12\x04\xa9\x02\x02\n\n\r\n\x05\x04\x1a\x02\x07\x05\
    \x12\x04\xa9\x02\x0b\x11\n\r\n\x05\x04\x1a\x02\x07\x01\x12\x04\xa9\x02\
    \x12%\n\r\n\x05\x04\x1a\x02\x07\x03\x12\x04\xa9\x02()\n\x0c\n\x04\x04\
    \x1a\x02\x08\x12\x04\xaa\x02\x02/\n\r\n\x05\x04\x1a\x02\x08\x04\x12\x04\
    \xaa\x02\x02\n\n\r\n\x05\x04\x1a\x02\x08\x05\x12\x04\xaa\x02\x0b\x11\n\r\
    \n\x05\x04\x1a\x02\x08\x01\x12\x04\xaa\x02\x12*\n\r\n\x05\x04\x1a\x02\
    \x08\x03\x12\x04\xaa\x02-.\n\x0c\n\x04\x04\x1a\x02\t\x12\x04\xab\x02\x02\
    \"\n\r\n\x05\x04\x1a\x02\t\x04\x12\x04\xab\x02\x02\n\n\r\n\x05\x04\x1a\
    \x02\t\x05\x12\x04\xab\x02\x0b\x11\n\r\n\x05\x04\x1a\x02\t\x01\x12\x04\
    \xab\x02\x12\x1c\n\r\n\x05\x04\x1a\x02\t\x03\x12\x04\xab\x02\x1f!\n\x0c\
    \n\x04\x04\x1a\x02\n\x12\x04\xac\x02\x02\x1f\n\r\n\x05\x04\x1a\x02\n\x06\
    \x12\x04\xac\x02\x02\r\n\r\n\x05\x04\x1a\x02\n\x01\x12\x04\xac\x02\x0e\
    \x19\n\r\n\x05\x04\x1a\x02\n\x03\x12\x04\xac\x02\x1c\x1e\n\x0c\n\x04\x04\
    \x1a\x02\x0b\x12\x04\xad\x02\x02!\n\r\n\x05\x04\x1a\x02\x0b\x06\x12\x04\
    \xad\x02\x02\x0e\n\r\n\x05\x04\x1a\x02\x0b\x01\x12\x04\xad\x02\x0f\x1b\n\
    \r\n\x05\x04\x1a\x02\x0b\x03\x12\x04\xad\x02\x1e\x20\n\x0c\n\x02\x04\x1b\
    \x12\x06\xb0\x02\0\xb8\x02\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xb0\x02\
    \x08\x13\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xb1\x02\x02\x1a\n\r\n\x05\x04\
    \x1b\x02\0\x05\x12\x04\xb1\x02\x02\x06\n\r\n\x05\x04\x1b\x02\0\x01\x12\
    \x04\xb1\x02\x07\x15\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xb1\x02\x18\x19\
    \n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xb2\x02\x02\x18\n\r\n\x05\x04\x1b\
    \x02\x01\x05\x12\x04\xb2\x02\x02\x06\n\r\n\x05\x04\x1b\x02\x01\x01\x12\
    \x04\xb2\x02\x07\x13\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xb2\x02\x16\
    \x17\n\x0c\n\x04\x04\x1b\x02\x02\x12\x04\xb3\x02\x02\x18\n\r\n\x05\x04\
    \x1b\x02\x02\x05\x12\x04\xb3\x02\x02\x06\n\r\n\x05\x04\x1b\x02\x02\x01\
    \x12\x04\xb3\x02\x07\x13\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xb3\x02\
    \x16\x17\n\x0c\n\x04\x04\x1b\x02\x03\x12\x04\xb4\x02\x02\x18\n\r\n\x05\
    \x04\x1b\x02\x03\x05\x12\x04\xb4\x02\x02\x06\n\r\n\x05\x04\x1b\x02\x03\
    \x01\x12\x04\xb4\x02\x07\x13\n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\xb4\
    \x02\x16\x17\n\x0c\n\x04\x04\x1b\x02\x04\x12\x04\xb5\x02\x02\x14\n\r\n\
    \x05\x04\x1b\x02\x04\x05\x12\x04\xb5\x02\x02\x06\n\r\n\x05\x04\x1b\x02\
    \x04\x01\x12\x04\xb5\x02\x07\x0f\n\r\n\x05\x04\x1b\x02\x04\x03\x12\x04\
    \xb5\x02\x12\x13\n\x0c\n\x04\x04\x1b\x02\x05\x12\x04\xb6\x02\x02\x17\n\r\
    \n\x05\x04\x1b\x02\x05\x05\x12\x04\xb6\x02\x02\x06\n\r\n\x05\x04\x1b\x02\
    \x05\x01\x12\x04\xb6\x02\x07\x12\n\r\n\x05\x04\x1b\x02\x05\x03\x12\x04\
    \xb6\x02\x15\x16\n\x0c\n\x04\x04\x1b\x02\x06\x12\x04\xb7\x02\x02\x17\n\r\
    \n\x05\x04\x1b\x02\x06\x05\x12\x04\xb7\x02\x02\x06\n\r\n\x05\x04\x1b\x02\
    \x06\x01\x12\x04\xb7\x02\x07\x12\n\r\n\x05\x04\x1b\x02\x06\x03\x12\x04\
    \xb7\x02\x15\x16\n\x0c\n\x02\x04\x1c\x12\x06\xba\x02\0\xc4\x02\x01\n\x0b\
    \n\x03\x04\x1c\x01\x12\x04\xba\x02\x08\x14\n\x0c\n\x04\x04\x1c\x02\0\x12\
    \x04\xbb\x02\x02\x1d\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\xbb\x02\x02\x06\
    \n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xbb\x02\x07\x18\n\r\n\x05\x04\x1c\
    \x02\0\x03\x12\x04\xbb\x02\x1b\x1c\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\
    \xbc\x02\x02\x1e\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xbc\x02\x02\x06\n\
    \r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xbc\x02\x07\x19\n\r\n\x05\x04\x1c\
    \x02\x01\x03\x12\x04\xbc\x02\x1c\x1d\n\x0c\n\x04\x04\x1c\x02\x02\x12\x04\
    \xbd\x02\x02\x12\n\r\n\x05\x04\x1c\x02\x02\x05\x12\x04\xbd\x02\x02\x06\n\
    \r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xbd\x02\x07\r\n\r\n\x05\x04\x1c\x02\
    \x02\x03\x12\x04\xbd\x02\x10\x11\n\x0c\n\x04\x04\x1c\x02\x03\x12\x04\xbe\
    \x02\x02\x20\n\r\n\x05\x04\x1c\x02\x03\x05\x12\x04\xbe\x02\x02\x06\n\r\n\
    \x05\x04\x1c\x02\x03\x01\x12\x04\xbe\x02\x07\x1b\n\r\n\x05\x04\x1c\x02\
    \x03\x03\x12\x04\xbe\x02\x1e\x1f\n\x0c\n\x04\x04\x1c\x02\x04\x12\x04\xbf\
    \x02\x02\x1a\n\r\n\x05\x04\x1c\x02\x04\x05\x12\x04\xbf\x02\x02\x06\n\r\n\
    \x05\x04\x1c\x02\x04\x01\x12\x04\xbf\x02\x07\x15\n\r\n\x05\x04\x1c\x02\
    \x04\x03\x12\x04\xbf\x02\x18\x19\n\x0c\n\x04\x04\x1c\x02\x05\x12\x04\xc0\
    \x02\x02\x1a\n\r\n\x05\x04\x1c\x02\x05\x05\x12\x04\xc0\x02\x02\x06\n\r\n\
    \x05\x04\x1c\x02\x05\x01\x12\x04\xc0\x02\x07\x15\n\r\n\x05\x04\x1c\x02\
    \x05\x03\x12\x04\xc0\x02\x18\x19\n\x0c\n\x04\x04\x1c\x02\x06\x12\x04\xc1\
    \x02\x02\x1b\n\r\n\x05\x04\x1c\x02\x06\x05\x12\x04\xc1\x02\x02\x06\n\r\n\
    \x05\x04\x1c\x02\x06\x01\x12\x04\xc1\x02\x07\x16\n\r\n\x05\x04\x1c\x02\
    \x06\x03\x12\x04\xc1\x02\x19\x1a\n\x0c\n\x04\x04\x1c\x02\x07\x12\x04\xc2\
    \x02\x02+\n\r\n\x05\x04\x1c\x02\x07\x04\x12\x04\xc2\x02\x02\n\n\r\n\x05\
    \x04\x1c\x02\x07\x05\x12\x04\xc2\x02\x0b\x11\n\r\n\x05\x04\x1c\x02\x07\
    \x01\x12\x04\xc2\x02\x12&\n\r\n\x05\x04\x1c\x02\x07\x03\x12\x04\xc2\x02)\
    *\n\x0c\n\x04\x04\x1c\x02\x08\x12\x04\xc3\x02\x02$\n\r\n\x05\x04\x1c\x02\
    \x08\x04\x12\x04\xc3\x02\x02\n\n\r\n\x05\x04\x1c\x02\x08\x05\x12\x04\xc3\
    \x02\x0b\x11\n\r\n\x05\x04\x1c\x02\x08\x01\x12\x04\xc3\x02\x12\x1f\n\r\n\
    \x05\x04\x1c\x02\x08\x03\x12\x04\xc3\x02\"#\n\x0c\n\x02\x04\x1d\x12\x06\
    \xc7\x02\0\xcc\x02\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xc7\x02\x08\x13\n\
    \x0c\n\x04\x04\x1d\x02\0\x12\x04\xc8\x02\x02\x14\n\r\n\x05\x04\x1d\x02\0\
    \x05\x12\x04\xc8\x02\x02\x08\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xc8\x02\
    \t\x0f\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xc8\x02\x12\x13\n\x0c\n\x04\
    \x04\x1d\x02\x01\x12\x04\xc9\x02\x02\x14\n\r\n\x05\x04\x1d\x02\x01\x05\
    \x12\x04\xc9\x02\x02\x08\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xc9\x02\t\
    \x0f\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xc9\x02\x12\x13\n\x0c\n\x04\
    \x04\x1d\x02\x02\x12\x04\xca\x02\x02\x17\n\r\n\x05\x04\x1d\x02\x02\x05\
    \x12\x04\xca\x02\x02\x08\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\xca\x02\t\
    \x12\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xca\x02\x15\x16\n\x0c\n\x04\
    \x04\x1d\x02\x03\x12\x04\xcb\x02\x02\x17\n\r\n\x05\x04\x1d\x02\x03\x05\
    \x12\x04\xcb\x02\x02\x08\n\r\n\x05\x04\x1d\x02\x03\x01\x12\x04\xcb\x02\t\
    \x12\n\r\n\x05\x04\x1d\x02\x03\x03\x12\x04\xcb\x02\x15\x16\n\x0c\n\x02\
    \x04\x1e\x12\x06\xcf\x02\0\xd7\x02\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\
    \xcf\x02\x08\x0c\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xd0\x02\x02\x10\n\r\n\
    \x05\x04\x1e\x02\0\x05\x12\x04\xd0\x02\x02\x08\n\r\n\x05\x04\x1e\x02\0\
    \x01\x12\x04\xd0\x02\t\x0b\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xd0\x02\
    \x0e\x0f\n\x0c\n\x04\x04\x1e\x02\x01\x12\x04\xd1\x02\x02\x12\n\r\n\x05\
    \x04\x1e\x02\x01\x05\x12\x04\xd1\x02\x02\x08\n\r\n\x05\x04\x1e\x02\x01\
    \x01\x12\x04\xd1\x02\t\r\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xd1\x02\
    \x10\x11\n\x0c\n\x04\x04\x1e\x02\x02\x12\x04\xd2\x02\x02\x16\n\r\n\x05\
    \x04\x1e\x02\x02\x05\x12\x04\xd2\x02\x02\x08\n\r\n\x05\x04\x1e\x02\x02\
    \x01\x12\x04\xd2\x02\t\x11\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\xd2\x02\
    \x14\x15\n\x0c\n\x04\x04\x1e\x02\x03\x12\x04\xd3\x02\x02\x17\n\r\n\x05\
    \x04\x1e\x02\x03\x05\x12\x04\xd3\x02\x02\x08\n\r\n\x05\x04\x1e\x02\x03\
    \x01\x12\x04\xd3\x02\t\x12\n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\xd3\x02\
    \x15\x16\n\x0c\n\x04\x04\x1e\x02\x04\x12\x04\xd4\x02\x02\x16\n\r\n\x05\
    \x04\x1e\x02\x04\x05\x12\x04\xd4\x02\x02\x08\n\r\n\x05\x04\x1e\x02\x04\
    \x01\x12\x04\xd4\x02\t\x11\n\r\n\x05\x04\x1e\x02\x04\x03\x12\x04\xd4\x02\
    \x14\x15\n\x0c\n\x04\x04\x1e\x02\x05\x12\x04\xd5\x02\x02\x1c\n\r\n\x05\
    \x04\x1e\x02\x05\x05\x12\x04\xd5\x02\x02\x07\n\r\n\x05\x04\x1e\x02\x05\
    \x01\x12\x04\xd5\x02\x08\x17\n\r\n\x05\x04\x1e\x02\x05\x03\x12\x04\xd5\
    \x02\x1a\x1b\n\x0c\n\x04\x04\x1e\x02\x06\x12\x04\xd6\x02\x02\x13\n\r\n\
    \x05\x04\x1e\x02\x06\x05\x12\x04\xd6\x02\x02\x08\n\r\n\x05\x04\x1e\x02\
    \x06\x01\x12\x04\xd6\x02\t\x0e\n\r\n\x05\x04\x1e\x02\x06\x03\x12\x04\xd6\
    \x02\x11\x12\n\x0c\n\x02\x04\x1f\x12\x06\xda\x02\0\xdf\x02\x01\n\x0b\n\
    \x03\x04\x1f\x01\x12\x04\xda\x02\x08\x0c\n\x0c\n\x04\x04\x1f\x02\0\x12\
    \x04\xdb\x02\x02\x18\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xdb\x02\x02\x08\
    \n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xdb\x02\t\x13\n\r\n\x05\x04\x1f\x02\
    \0\x03\x12\x04\xdb\x02\x16\x17\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\xdc\
    \x02\x02\x18\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\xdc\x02\x02\x08\n\r\n\
    \x05\x04\x1f\x02\x01\x01\x12\x04\xdc\x02\t\x13\n\r\n\x05\x04\x1f\x02\x01\
    \x03\x12\x04\xdc\x02\x16\x17\n\x0c\n\x04\x04\x1f\x02\x02\x12\x04\xdd\x02\
    \x02\x18\n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\xdd\x02\x02\x08\n\r\n\x05\
    \x04\x1f\x02\x02\x01\x12\x04\xdd\x02\t\x13\n\r\n\x05\x04\x1f\x02\x02\x03\
    \x12\x04\xdd\x02\x16\x17\n\x0c\n\x04\x04\x1f\x02\x03\x12\x04\xde\x02\x02\
    \x18\n\r\n\x05\x04\x1f\x02\x03\x06\x12\x04\xde\x02\x02\n\n\r\n\x05\x04\
    \x1f\x02\x03\x01\x12\x04\xde\x02\x0b\x13\n\r\n\x05\x04\x1f\x02\x03\x03\
    \x12\x04\xde\x02\x16\x17\n\x0c\n\x02\x04\x20\x12\x06\xe1\x02\0\xe4\x02\
    \x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xe1\x02\x08\x10\n\x0c\n\x04\x04\x20\
    \x02\0\x12\x04\xe2\x02\x02\x16\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xe2\
    \x02\x02\x07\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xe2\x02\x08\x11\n\r\n\
    \x05\x04\x20\x02\0\x03\x12\x04\xe2\x02\x14\x15\n\x0c\n\x04\x04\x20\x02\
    \x01\x12\x04\xe3\x02\x02\x16\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\xe3\
    \x02\x02\x07\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\xe3\x02\x08\x11\n\r\n\
    \x05\x04\x20\x02\x01\x03\x12\x04\xe3\x02\x14\x15\n\x0c\n\x02\x04!\x12\
    \x06\xe7\x02\0\xf9\x02\x01\n\x0b\n\x03\x04!\x01\x12\x04\xe7\x02\x08\x12\
    \n\x0c\n\x04\x04!\x02\0\x12\x04\xe8\x02\x02\x1c\n\r\n\x05\x04!\x02\0\x05\
    \x12\x04\xe8\x02\x02\x08\n\r\n\x05\x04!\x02\0\x01\x12\x04\xe8\x02\t\x17\
    \n\r\n\x05\x04!\x02\0\x03\x12\x04\xe8\x02\x1a\x1b\n\x0c\n\x04\x04!\x02\
    \x01\x12\x04\xe9\x02\x02\"\n\r\n\x05\x04!\x02\x01\x05\x12\x04\xe9\x02\
    \x02\x08\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xe9\x02\t\x1d\n\r\n\x05\x04!\
    \x02\x01\x03\x12\x04\xe9\x02\x20!\n\x0c\n\x04\x04!\x02\x02\x12\x04\xea\
    \x02\x02\x18\n\r\n\x05\x04!\x02\x02\x05\x12\x04\xea\x02\x02\x08\n\r\n\
    \x05\x04!\x02\x02\x01\x12\x04\xea\x02\t\x13\n\r\n\x05\x04!\x02\x02\x03\
    \x12\x04\xea\x02\x16\x17\n\x0c\n\x04\x04!\x02\x03\x12\x04\xeb\x02\x02\
    \x18\n\r\n\x05\x04!\x02\x03\x05\x12\x04\xeb\x02\x02\x08\n\r\n\x05\x04!\
    \x02\x03\x01\x12\x04\xeb\x02\t\x13\n\r\n\x05\x04!\x02\x03\x03\x12\x04\
    \xeb\x02\x16\x17\n\x0c\n\x04\x04!\x02\x04\x12\x04\xec\x02\x02\x1c\n\r\n\
    \x05\x04!\x02\x04\x05\x12\x04\xec\x02\x02\x08\n\r\n\x05\x04!\x02\x04\x01\
    \x12\x04\xec\x02\t\x17\n\r\n\x05\x04!\x02\x04\x03\x12\x04\xec\x02\x1a\
    \x1b\n\x0c\n\x04\x04!\x02\x05\x12\x04\xed\x02\x02\x18\n\r\n\x05\x04!\x02\
    \x05\x05\x12\x04\xed\x02\x02\x08\n\r\n\x05\x04!\x02\x05\x01\x12\x04\xed\
    \x02\t\x13\n\r\n\x05\x04!\x02\x05\x03\x12\x04\xed\x02\x16\x17\n\x0c\n\
    \x04\x04!\x02\x06\x12\x04\xee\x02\x02\x18\n\r\n\x05\x04!\x02\x06\x05\x12\
    \x04\xee\x02\x02\x08\n\r\n\x05\x04!\x02\x06\x01\x12\x04\xee\x02\t\x13\n\
    \r\n\x05\x04!\x02\x06\x03\x12\x04\xee\x02\x16\x17\n\x0c\n\x04\x04!\x02\
    \x07\x12\x04\xef\x02\x02\x1c\n\r\n\x05\x04!\x02\x07\x05\x12\x04\xef\x02\
    \x02\x08\n\r\n\x05\x04!\x02\x07\x01\x12\x04\xef\x02\t\x17\n\r\n\x05\x04!\
    \x02\x07\x03\x12\x04\xef\x02\x1a\x1b\n\x0c\n\x04\x04!\x02\x08\x12\x04\
    \xf0\x02\x02\x20\n\r\n\x05\x04!\x02\x08\x05\x12\x04\xf0\x02\x02\x06\n\r\
    \n\x05\x04!\x02\x08\x01\x12\x04\xf0\x02\x07\x1b\n\r\n\x05\x04!\x02\x08\
    \x03\x12\x04\xf0\x02\x1e\x1f\n\x0c\n\x04\x04!\x02\t\x12\x04\xf1\x02\x02\
    \x1c\n\r\n\x05\x04!\x02\t\x05\x12\x04\xf1\x02\x02\x08\n\r\n\x05\x04!\x02\
    \t\x01\x12\x04\xf1\x02\t\x16\n\r\n\x05\x04!\x02\t\x03\x12\x04\xf1\x02\
    \x19\x1b\n\x0c\n\x04\x04!\x02\n\x12\x04\xf2\x02\x02\x14\n\r\n\x05\x04!\
    \x02\n\x05\x12\x04\xf2\x02\x02\x06\n\r\n\x05\x04!\x02\n\x01\x12\x04\xf2\
    \x02\x07\x0e\n\r\n\x05\x04!\x02\n\x03\x12\x04\xf2\x02\x11\x13\n\x0c\n\
    \x04\x04!\x02\x0b\x12\x04\xf3\x02\x02\x14\n\r\n\x05\x04!\x02\x0b\x05\x12\
    \x04\xf3\x02\x02\x06\n\r\n\x05\x04!\x02\x0b\x01\x12\x04\xf3\x02\x07\x0e\
    \n\r\n\x05\x04!\x02\x0b\x03\x12\x04\xf3\x02\x11\x13\n\x0c\n\x04\x04!\x02\
    \x0c\x12\x04\xf4\x02\x02\x16\n\r\n\x05\x04!\x02\x0c\x05\x12\x04\xf4\x02\
    \x02\x08\n\r\n\x05\x04!\x02\x0c\x01\x12\x04\xf4\x02\t\x10\n\r\n\x05\x04!\
    \x02\x0c\x03\x12\x04\xf4\x02\x13\x15\n\x0c\n\x04\x04!\x02\r\x12\x04\xf5\
    \x02\x02\x15\n\r\n\x05\x04!\x02\r\x05\x12\x04\xf5\x02\x02\x08\n\r\n\x05\
    \x04!\x02\r\x01\x12\x04\xf5\x02\t\x0f\n\r\n\x05\x04!\x02\r\x03\x12\x04\
    \xf5\x02\x12\x14\n\x0c\n\x04\x04!\x02\x0e\x12\x04\xf6\x02\x02\x17\n\r\n\
    \x05\x04!\x02\x0e\x05\x12\x04\xf6\x02\x02\x08\n\r\n\x05\x04!\x02\x0e\x01\
    \x12\x04\xf6\x02\t\x11\n\r\n\x05\x04!\x02\x0e\x03\x12\x04\xf6\x02\x14\
    \x16\n\x0c\n\x04\x04!\x02\x0f\x12\x04\xf7\x02\x02\x17\n\r\n\x05\x04!\x02\
    \x0f\x05\x12\x04\xf7\x02\x02\x07\n\r\n\x05\x04!\x02\x0f\x01\x12\x04\xf7\
    \x02\x08\x11\n\r\n\x05\x04!\x02\x0f\x03\x12\x04\xf7\x02\x14\x16\n\x0c\n\
    \x04\x04!\x02\x10\x12\x04\xf8\x02\x02\x1d\n\r\n\x05\x04!\x02\x10\x04\x12\
    \x04\xf8\x02\x02\n\n\r\n\x05\x04!\x02\x10\x05\x12\x04\xf8\x02\x0b\x11\n\
    \r\n\x05\x04!\x02\x10\x01\x12\x04\xf8\x02\x12\x17\n\r\n\x05\x04!\x02\x10\
    \x03\x12\x04\xf8\x02\x1a\x1c\n\x0c\n\x02\x04\"\x12\x06\xfc\x02\0\x85\x03\
    \x01\n\x0b\n\x03\x04\"\x01\x12\x04\xfc\x02\x08\x1e\n\x0c\n\x04\x04\"\x02\
    \0\x12\x04\xfd\x02\x02\x10\n\r\n\x05\x04\"\x02\0\x05\x12\x04\xfd\x02\x02\
    \x08\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xfd\x02\t\x0b\n\r\n\x05\x04\"\x02\
    \0\x03\x12\x04\xfd\x02\x0e\x0f\n\x0c\n\x04\x04\"\x02\x01\x12\x04\xfe\x02\
    \x02\x12\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\xfe\x02\x02\x08\n\r\n\x05\
    \x04\"\x02\x01\x01\x12\x04\xfe\x02\t\r\n\r\n\x05\x04\"\x02\x01\x03\x12\
    \x04\xfe\x02\x10\x11\n\x0c\n\x04\x04\"\x02\x02\x12\x04\xff\x02\x02\x12\n\
    \r\n\x05\x04\"\x02\x02\x05\x12\x04\xff\x02\x02\x08\n\r\n\x05\x04\"\x02\
    \x02\x01\x12\x04\xff\x02\t\r\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xff\x02\
    \x10\x11\n\x0c\n\x04\x04\"\x02\x03\x12\x04\x80\x03\x02\x18\n\r\n\x05\x04\
    \"\x02\x03\x05\x12\x04\x80\x03\x02\x08\n\r\n\x05\x04\"\x02\x03\x01\x12\
    \x04\x80\x03\t\x13\n\r\n\x05\x04\"\x02\x03\x03\x12\x04\x80\x03\x16\x17\n\
    \x0c\n\x04\x04\"\x02\x04\x12\x04\x81\x03\x02\x16\n\r\n\x05\x04\"\x02\x04\
    \x05\x12\x04\x81\x03\x02\x08\n\r\n\x05\x04\"\x02\x04\x01\x12\x04\x81\x03\
    \t\x11\n\r\n\x05\x04\"\x02\x04\x03\x12\x04\x81\x03\x14\x15\n\x0c\n\x04\
    \x04\"\x02\x05\x12\x04\x82\x03\x02\x18\n\r\n\x05\x04\"\x02\x05\x05\x12\
    \x04\x82\x03\x02\x08\n\r\n\x05\x04\"\x02\x05\x01\x12\x04\x82\x03\t\x13\n\
    \r\n\x05\x04\"\x02\x05\x03\x12\x04\x82\x03\x16\x17\n\x0c\n\x04\x04\"\x02\
    \x06\x12\x04\x83\x03\x02\x14\n\r\n\x05\x04\"\x02\x06\x05\x12\x04\x83\x03\
    \x02\x06\n\r\n\x05\x04\"\x02\x06\x01\x12\x04\x83\x03\x07\x0f\n\r\n\x05\
    \x04\"\x02\x06\x03\x12\x04\x83\x03\x12\x13\n\x0c\n\x04\x04\"\x02\x07\x12\
    \x04\x84\x03\x02/\n\r\n\x05\x04\"\x02\x07\x04\x12\x04\x84\x03\x02\n\n\r\
    \n\x05\x04\"\x02\x07\x06\x12\x04\x84\x03\x0b!\n\r\n\x05\x04\"\x02\x07\
    \x01\x12\x04\x84\x03\"*\n\r\n\x05\x04\"\x02\x07\x03\x12\x04\x84\x03-.\n\
    \x0c\n\x02\x04#\x12\x06\x87\x03\0\x94\x03\x01\n\x0b\n\x03\x04#\x01\x12\
    \x04\x87\x03\x08\x16\n\x0c\n\x04\x04#\x02\0\x12\x04\x88\x03\x02\x1e\n\r\
    \n\x05\x04#\x02\0\x05\x12\x04\x88\x03\x02\x08\n\r\n\x05\x04#\x02\0\x01\
    \x12\x04\x88\x03\t\x19\n\r\n\x05\x04#\x02\0\x03\x12\x04\x88\x03\x1c\x1d\
    \n\x0c\n\x04\x04#\x02\x01\x12\x04\x89\x03\x02\x1e\n\r\n\x05\x04#\x02\x01\
    \x05\x12\x04\x89\x03\x02\x08\n\r\n\x05\x04#\x02\x01\x01\x12\x04\x89\x03\
    \t\x19\n\r\n\x05\x04#\x02\x01\x03\x12\x04\x89\x03\x1c\x1d\n\x0c\n\x04\
    \x04#\x02\x02\x12\x04\x8a\x03\x023\n\r\n\x05\x04#\x02\x02\x04\x12\x04\
    \x8a\x03\x02\n\n\r\n\x05\x04#\x02\x02\x06\x12\x04\x8a\x03\x0b!\n\r\n\x05\
    \x04#\x02\x02\x01\x12\x04\x8a\x03\".\n\r\n\x05\x04#\x02\x02\x03\x12\x04\
    \x8a\x0312\n\x0c\n\x04\x04#\x02\x03\x12\x04\x8b\x03\x02\x19\n\r\n\x05\
    \x04#\x02\x03\x05\x12\x04\x8b\x03\x02\x08\n\r\n\x05\x04#\x02\x03\x01\x12\
    \x04\x8b\x03\t\x14\n\r\n\x05\x04#\x02\x03\x03\x12\x04\x8b\x03\x17\x18\n\
    \x0c\n\x04\x04#\x02\x04\x12\x04\x8c\x03\x02\x19\n\r\n\x05\x04#\x02\x04\
    \x05\x12\x04\x8c\x03\x02\x08\n\r\n\x05\x04#\x02\x04\x01\x12\x04\x8c\x03\
    \t\x14\n\r\n\x05\x04#\x02\x04\x03\x12\x04\x8c\x03\x17\x18\n\x0c\n\x04\
    \x04#\x02\x05\x12\x04\x8d\x03\x02.\n\r\n\x05\x04#\x02\x05\x04\x12\x04\
    \x8d\x03\x02\n\n\r\n\x05\x04#\x02\x05\x06\x12\x04\x8d\x03\x0b!\n\r\n\x05\
    \x04#\x02\x05\x01\x12\x04\x8d\x03\")\n\r\n\x05\x04#\x02\x05\x03\x12\x04\
    \x8d\x03,-\n\x0c\n\x04\x04#\x02\x06\x12\x04\x8e\x03\x02\x1a\n\r\n\x05\
    \x04#\x02\x06\x05\x12\x04\x8e\x03\x02\x08\n\r\n\x05\x04#\x02\x06\x01\x12\
    \x04\x8e\x03\t\x15\n\r\n\x05\x04#\x02\x06\x03\x12\x04\x8e\x03\x18\x19\n\
    \x0c\n\x04\x04#\x02\x07\x12\x04\x8f\x03\x02\x1a\n\r\n\x05\x04#\x02\x07\
    \x05\x12\x04\x8f\x03\x02\x08\n\r\n\x05\x04#\x02\x07\x01\x12\x04\x8f\x03\
    \t\x15\n\r\n\x05\x04#\x02\x07\x03\x12\x04\x8f\x03\x18\x19\n\x0c\n\x04\
    \x04#\x02\x08\x12\x04\x90\x03\x02/\n\r\n\x05\x04#\x02\x08\x04\x12\x04\
    \x90\x03\x02\n\n\r\n\x05\x04#\x02\x08\x06\x12\x04\x90\x03\x0b!\n\r\n\x05\
    \x04#\x02\x08\x01\x12\x04\x90\x03\"*\n\r\n\x05\x04#\x02\x08\x03\x12\x04\
    \x90\x03-.\n\x0c\n\x04\x04#\x02\t\x12\x04\x91\x03\x02\x18\n\r\n\x05\x04#\
    \x02\t\x05\x12\x04\x91\x03\x02\x08\n\r\n\x05\x04#\x02\t\x01\x12\x04\x91\
    \x03\t\x12\n\r\n\x05\x04#\x02\t\x03\x12\x04\x91\x03\x15\x17\n\x0c\n\x04\
    \x04#\x02\n\x12\x04\x92\x03\x02\x18\n\r\n\x05\x04#\x02\n\x05\x12\x04\x92\
    \x03\x02\x08\n\r\n\x05\x04#\x02\n\x01\x12\x04\x92\x03\t\x12\n\r\n\x05\
    \x04#\x02\n\x03\x12\x04\x92\x03\x15\x17\n\x0c\n\x04\x04#\x02\x0b\x12\x04\
    \x93\x03\x02-\n\r\n\x05\x04#\x02\x0b\x04\x12\x04\x93\x03\x02\n\n\r\n\x05\
    \x04#\x02\x0b\x06\x12\x04\x93\x03\x0b!\n\r\n\x05\x04#\x02\x0b\x01\x12\
    \x04\x93\x03\"'\n\r\n\x05\x04#\x02\x0b\x03\x12\x04\x93\x03*,b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::annotations::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(36);
            messages.push(MessageRequest::generated_message_descriptor_data());
            messages.push(PluginInfo::generated_message_descriptor_data());
            messages.push(PluginResponse::generated_message_descriptor_data());
            messages.push(PluginList::generated_message_descriptor_data());
            messages.push(GetObjectsValuesResponse::generated_message_descriptor_data());
            messages.push(GetObjectValuesResponse::generated_message_descriptor_data());
            messages.push(ObjectsValuesRequest::generated_message_descriptor_data());
            messages.push(ObjectsValueRequest::generated_message_descriptor_data());
            messages.push(PortRequest::generated_message_descriptor_data());
            messages.push(PortValue::generated_message_descriptor_data());
            messages.push(ValueTransformation::generated_message_descriptor_data());
            messages.push(ObjectsRequest::generated_message_descriptor_data());
            messages.push(PalletRequest::generated_message_descriptor_data());
            messages.push(PalletTree::generated_message_descriptor_data());
            messages.push(Plugin::generated_message_descriptor_data());
            messages.push(NestedObjectConfigMap::generated_message_descriptor_data());
            messages.push(Command::generated_message_descriptor_data());
            messages.push(CommandResponse::generated_message_descriptor_data());
            messages.push(PingRequest::generated_message_descriptor_data());
            messages.push(PingResponse::generated_message_descriptor_data());
            messages.push(ObjectDeploy::generated_message_descriptor_data());
            messages.push(Empty::generated_message_descriptor_data());
            messages.push(ObjectsResponse::generated_message_descriptor_data());
            messages.push(ObjectRequest::generated_message_descriptor_data());
            messages.push(ObjectConfig::generated_message_descriptor_data());
            messages.push(Settings::generated_message_descriptor_data());
            messages.push(Info::generated_message_descriptor_data());
            messages.push(Permissions::generated_message_descriptor_data());
            messages.push(Requirements::generated_message_descriptor_data());
            messages.push(ObjectStats::generated_message_descriptor_data());
            messages.push(Port::generated_message_descriptor_data());
            messages.push(Meta::generated_message_descriptor_data());
            messages.push(Position::generated_message_descriptor_data());
            messages.push(Connection::generated_message_descriptor_data());
            messages.push(ObjectExtractedDetails::generated_message_descriptor_data());
            messages.push(ObjectsRootMap::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
